<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>Linux下的字体管理</title><url>/posts/linux-fonts-manager/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[本文介绍Linux下的字体管理，不同字体族之间的关系，使用Fontconig管理字体，推荐了几款我使用的优秀字体。
三个通用字体族名 (generic family) snas-serif 无衬线 serif 衬线 monospace 等宽字体 ttf 和otf 的区别 TTF（TrueType Font）是Apple公司和Microsoft公司共同推出的字体文件格式，随着windows的流行，已经变成最常用的一种字体文件表示方式。 而OTF（OpenType Font）是TTF 的升级版，而OTF 是采用的是PostScript 曲线，支持OpenType 高级特性的更高级字体。
字体文件存储目录 /usr/share/fonts —&gt; 包管理安装 /usr/local/share/fonts —&gt; 自己手动安装的全局字体
终端中查看字体
alias sf=&#39;fc-list : family style | fzf&#39; 中文字体 中文字体推荐谷歌的思源黑体Noto Sans SC，华为的鸿蒙黑体HarmonyOS Sans SC，小米的MiSans
$ yay -S ttf-harmonyos-sans Nerd字体 Nerd字体 可以为原来的等宽字体添加图标，icon等符号，多用于终端和编程环境中，丰富显示效果，常用的Nerd字体。
 yay -Qsq nerd otf-comicshanns-nerd otf-commit-mono-nerd ttf-cascadia-code-nerd ttf-fantasque-nerd ttf-firacode-nerd ttf-inconsolata-nerd ttf-nerd-fonts-symbols ttf-nerd-fonts-symbols-common ttf-roboto-mono-nerd emoji字体 # Twitter推出的emoji字体 $ yay -S ttf-twemoji-color # Google Noto emoji fonts $ yay -S extra/noto-fonts-emoji Fontconfig Fontconfig可以用来对Linux下的字体进行统一的管理，任何使用 fontconfig 的程序都会遵守这一标准，不用为每个APP单独设置字体，统一使用字体族名就可以了。
$ nvim ~/.config/fontconfig/fonts.conf &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;!DOCTYPE fontconfig SYSTEM &#34;urn:fontconfig:fonts.dtd&#34;&gt; &lt;fontconfig&gt; &lt;alias&gt; &lt;family&gt;serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Noto Serif&lt;/family&gt; &lt;family&gt;Twitter Color Emoji&lt;/family&gt; &lt;family&gt;Noto Color Emoji&lt;/family&gt; &lt;family&gt;Symbols Nerd Font&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;sans-serif&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;HarmonyOS Sans SC&lt;/family&gt; &lt;family&gt;Noto Sans SC&lt;/family&gt; &lt;family&gt;Twitter Color Emoji&lt;/family&gt; &lt;family&gt;Noto Color Emoji&lt;/family&gt; &lt;family&gt;Symbols Nerd Font&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;alias&gt; &lt;family&gt;monospace&lt;/family&gt; &lt;prefer&gt; &lt;family&gt;Monaco Nerd Font&lt;/family&gt; &lt;family&gt;RobotoMono Nerd Font&lt;/family&gt; &lt;family&gt;FiraCode Nerd Font Mono&lt;/family&gt; &lt;family&gt;Noto Sans Mono&lt;/family&gt; &lt;family&gt;Noto Color Emoji&lt;/family&gt; &lt;family&gt;Braille&lt;/family&gt; &lt;/prefer&gt; &lt;/alias&gt; &lt;/fontconfig&gt; Unicode 2023 年每个软件开发者都必须知道的关于 Unicode 的最基本的知识 https://blog.xinshijiededa.men/unicode/ 参考 How to Install and Manage Fonts on Linux https://youtu.be/1RtLyPzbttA fontconfig的原理 https://catcat.cc/post/2021-03-07/ ]]></content></entry><entry><title>Arch Linux设置rofi</title><url>/posts/arch-rofi-setup/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[ rofi : A window switcher, run dialog and dmenu replacement. 简单说就相当于我们使用的utools, 可以启动应用，搜索文件，搜索emoji,执行命令等。但utools在Arch Linux的KDE Plasma桌面环境的兼容性不好，于是找到了替代品rofi.试了一下，效果很不错，分享一下自己的配置。
我所使用的窗口管理器是wayland,所以安装该环境下的兼容版本。
Rofi支持下面的模式（Modes）
run: launch applications from $PATH, with option to launch in terminal. drun: launch applications based on desktop files. It tries to be compliant to the XDG standard. window: Switch between windows on an EWMH compatible window manager. ssh: Connect to a remote host via ssh. filebrowser: A basic file-browser for opening files. keys: list internal keybindings. script: Write (limited) custom mode using simple scripts. combi: Combine multiple modes into one. 可以按 Shift+左右方向键切换不同的Modes.
1. 安装 # 或者使用yay安装 ~$ sudo pacman -S chaotic-aur/rofi-lbonn-wayland # emoji搜索支持 ~$ sudo pacman -S community/rofi-emoji 要把emoji复制到剪切板，需要安装
~$ sudo pacman -S wl-clipboard 2. 配置 ~$ mkdir -p ~/.config/rofi # 生成默认配置 ~$ rofi -dump-config &gt; ~/.config/rofi/config.rasi 由于我的KDE桌面的主题是Nordic,所以rofi也安装这个主题，比较搭配。安装 Nordic主题 ，下载nord.rasi文件放到~/.config/rofi/config.rasi下，修改配置文件引用该主题，也可添加自定义的设置,下面是我的配置
~$ vim ~/.config/rofi/config.rasi /** Basic config file **/ configuration { modes: [combi]; modi: &#34;drun,run,filebrowser,emoji,ssh,combi&#34;; font: &#34;MiSans 20&#34;; width: 24; display-ssh: &#34;&#34;; display-emoji: &#34;&#34;; display-filebrowser: &#34;&#34;; display-run: &#34;&#34;; display-drun: &#34;&#34;; drun-display-format: &#34;{icon} {name}&#34;; display-window: &#34;&#34;; display-combi: &#34;&#34;; show-icons: true; //icon-theme: &#34;Papirus&#34;; icon-theme: &#34;Tela circle purple dark&#34;; } //setup theme @theme &#34;nord&#34; 3. 设置全局快捷键 在系统设置–&gt; 快捷键 –&gt; 自定义快捷键 设置启动rofi的快捷键，我设置的是Alt+Return
4. 效果展示 4. 参考 https://github.com/lbonn/rofi https://github.com/undiabler/nord-rofi-theme ]]></content></entry><entry><title>Linux 环境下部署Apache Tomcat Server</title><url>/posts/apache-tomcat-setup/</url><categories><category>Tomat</category></categories><tags><tag>Linux</tag><tag>Tomcat</tag></tags><content type="html"><![CDATA[Tomcat 是 Apache 软件基金会（Apache Software Foundation）的 Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的 Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的 Web 应用服务器。
Tomcat结构 Tomcat中最顶层的容器是Server，代表着整个服务器，一个Server可以包含至少一个Service，用于具体提供服务。 Service主要包含两个部分：Connector和Container。
Tomcat 的核心就是这两个组件，他们的作用如下：
Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化; Container用于封装和管理Servlet，以及具体处理Request请求； Tomcat服务器搭建 本次使用JDK11和Tomcat10版本进行部署.
JDK环境安装 下载安装 Java Archive Downloads - Java SE 11 (oracle.com) ~$ wget https://download.java.net/java/ga/jdk11/openjdk-11_linux-x64_bin.tar.gz ~$ tar -zxf openjdk-11_linux-x64_bin.tar.gz ~$ sudo mv jdk-11 /usr/local/jdk 配置JDK环境变量 ~$ sudo vim /etc/profile.d/jdk.sh JAVA_HOME=/usr/local/jdk CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH # 验证 [xdl@CentOS] ~$ source /etc/profile [xdl@CentOS] ~$ java -version openjdk version &#34;11&#34; 2018-09-25 OpenJDK Runtime Environment 18.9 (build 11+28) OpenJDK 64-Bit Server VM 18.9 (build 11+28, mixed mode) 安装Tomcat Apache Tomcat® - Apache Tomcat 10 Software Downloads 安装
~$ tar -zxf apache-tomcat-10.0.14.tar.gz ~$ sudo mv apache-tomcat-10.0.14 /usr/local/tomcat Tomcat管理 启动Tomcat ~$ /usr/local/tomcat/bin/startup.sh 查看启动日志 ~$ tail -f /usr/local/tomcat/logs/catalina.out 查看监听端口 ~$ sudo ss -antpl |grep java 可以看到Tomcat监听了8080,8005
开放防火墙端口 ~$ sudo firewall-cmd --add-port=8080/tcp --permanent ~$ sudo firewall-cmd --reload 浏览器访问 http://ip:8080便可以访问测试页面
修改配置文件 ~$ sudo vim /usr/local/tomcat/conf/server.xml 停止服务 ~$ /usr/local/tomcat/bin/shutdown.sh JAVA应用的war包放在/usr/local/tomcat/webapps/里，并删除ROOT目录。改变server.xml文件中的server区域
&lt;Host name=&#34;localhost&#34; appBase=&#34;webapps&#34; unpackWARs=&#34;true&#34; autoDeploy=&#34;true&#34;&gt; &lt;Context path=&#34;&#34; docBase=&#34;hjc&#34; debug=&#34;0&#34; privileged=&#34;true&#34;/&gt; #加入此行 &lt;/Host&gt; &lt;/Engine&gt; &lt;/Service&gt; &lt;/Server&gt; 重启Tomcat ~$ /usr/local/tomcat/bin/shutdown.sh ~$ /usr/local/tomcat/bin/startup.sh 设置Tomcat的环境变量 $ vim /etc/profile.d/tomcat.sh #TOMCAT export TOMCAT_HOME=/usr/local/tomcat export PATH=$PATH:$TOMCAT_HOME/bin ]]></content></entry><entry><title>CentOS设置KVM虚拟化环境</title><url>/posts/centos-setup-kvm/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag><tag>KVM</tag></tags><content type="html"><![CDATA[Kernel-based Virtual Machine (KVM)是一种集成到Linux的开源的虚拟化解决方案，它是一个内核模块把Linux变成物理虚拟化平台用来运行virtual machines (VMs).下面介绍在CentOS/Rocky Linux8上搭建KVM虚拟化环境。
KVM虚拟化架构图 验证环境 检查CPU的虚拟化技术 # Intel CPU grep -e &#39;vmx&#39; /proc/cpuinfo # AMD CPU grep -e &#39;svm&#39; /proc/cpuinfo 验证内核的KVM模块是否开启 lsmod | grep kvm 设置cockpit web管理接口 安装cockpit dnf install cockpit cockpit-machines 设置开机自启 sudo systemctl enable --now cockpit.socket 开放防火墙端口 firewall-cmd --add-service=cockpit --permanent firewall-cmd --reload 使用浏览器访问https://servr_ip:9090端口就能打开web管理界面
设置虚拟化环境 安装虚拟化模块 dnf module install virt dnf install virt-install virt-viewer 验证驱动 virt-host-validate 设置服务的开机自启 sudo systemctl enable --now libvirtd.service 添加桥接设备 在cockpit web界面的网络 &ndash;&gt; 添加桥接 &ndash;&gt; 端口选择你的真实网卡
使用命令行添加网桥设备
# 添加一个网桥设备br0 ip link add name br0 type bridge # 启用br0 ip link set dev br0 up # 添加网络端口到到网桥中，要求先将端口设置为混杂模式 ip link set dev ens33 promisc on ip link set dev ens33 up ip link set dev ens33 master br0 # 显示现存的网桥和关联的端口 bridge link show ]]></content></entry><entry><title>About me</title><url>/about/</url><categories/><tags/><content type="html">About Me!! 世界那么大，你我在这里相遇！
技术宅,暖男 Linuxer YouTube和哔哩哔哩重度用户 GitHub常驻用户 知乎划水用户 树莓派资深玩家 Python爬虫中级玩家 Docker重度用户 GUN/Linux开源爱好者 信奉vim是最好的编辑器 座右铭: 人生是赛跑，但是比的是跑得远而不是跑的快，所以一直向前跑的人才会赢。 最大的梦想: 实现财富自由提前退休去旅游。 推荐 1、 Vultr服务器-注册送10$ 2、 DigtalOcean服务器-注册送10$ 3、 滴滴云服务器-注册送优惠券 4、 ProcessOn在线绘图 5、 Affnity Photo教程-注册送100￥ 6、 阿里云服务器优惠 个人简历: 教育背景：本科（SYSU） 专业：电子信息科学与技术 职业： Linux运维工程师 技能：云计算Linux,Docker/K8s,Ansible,Python,IoT&amp;hellip;&amp;hellip; 系统：Windows11 Pro|CentOS(Rocky Linux)|Raspbian|Arch Linux|OpenWrt 兴趣：喜欢看火影、龙珠🐲、漫威英雄电影，桌球，旅游，无聊时瞎折腾！ 转折：2017年9月决心从EE转云计算Linux方向! 联系我: CSDN博客： CSDN Mail: pengshp3 AT outlook.com QQ: 1723549711[注明来意] Telegram: Victor 添加友链请 Mail me!</content></entry><entry><title>MyCat实现MySQL数据的读写分离</title><url>/posts/mycat-mariadb-write-read/</url><categories><category>MySQL</category></categories><tags><tag>Linux</tag><tag>MySQL</tag></tags><content type="html"><![CDATA[
MyCat是开源社区在阿里cobar基础上使用Java进行二次开发的开源数据库中间件,本文介绍使用 MyCat 实现读写分离.
MyCat简介 MyCat是开源社区在阿里cobar基础上使用Java进行二次开发的开源数据库中间件；是一个开源的分布式数据库系统，是一个实现了MySQL协议的的Server，前端用户可以把它看作是一个数据库代理，用MySQL客户端工具和命令行访问，而其后端可以用MySQL原生（Native）协议与多个MySQL服务器通信，也可以用JDBC协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为N个小表，存储在后端MySQL服务器里或者其他数据库里。
Mycat发展到目前的版本，已经不是一个单纯的MySQL代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL等主流数据库，也支持MongoDB这种新型NoSQL方式的存储，未来还会支持更多类型的存储。
对于DBA来说，可以这么理解Mycat： Mycat就是MySQL Server，而Mycat后面连接的MySQL Server，就好象是MySQL的存储引擎,如InnoDB，MyISAM等，因此，Mycat本身并不存储数据，数据是在后端的MySQL上存储的，因此数据可靠性以及事务等都是MySQL保证的；
对于架构师来说，可以这么理解Mycat：Mycat是一个强大的数据库中间件，不仅仅可以用作读写分离、以及分表分库、容灾备份，而且可以用于多租户应用开发、云平台基础设施、让你的架构具备很强的适应性和灵活性，借助于即将发布的Mycat智能优化模块，系统的数据访问瓶颈和热点一目了然，根据这些统计分析数据，你可以自动或手工调整后端存储，将不同的表映射到不同存储引擎上，而整个应用的代码一行也不用改变。
Mycat1.6官网 Mycat1权威指南 · 语雀 (yuque.com) MyCat作用 读写分离
数据分片
垂直拆分（分库）、水平拆分（分表）、垂直+水平拆分（分库分表）
多数据源整合 MyCat原理 Mycat 的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的 SQL 语句，首先对 SQL 语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此 SQL 发往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户。
MyCat安装 安装java运行环境JDK $ sudo wget http://dl.mycat.org.cn/jdk-8u20-linux-x64.tar.gz $ sudo tar -zxf jdk-8u20-linux-x64.tar.gz $ sudo mv jdk1.8.0_20 /usr/local/jdk # 配置环境变量 ~$ sudo vim /etc/profile.d/jdk.sh JAVA_HOME=/usr/local/jdk JRE_HOME=$JAVA_HOME/jre CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME JRE_HOME CLASSPATH PATH # 验证 [xdl@CentOS] ~$ source /etc/profile [xdl@CentOS] ~$ java -version java version &#34;1.8.0_20&#34; Java(TM) SE Runtime Environment (build 1.8.0_20-b26) Java HotSpot(TM) 64-Bit Server VM (build 25.20-b23, mixed mode) MyCat安装 ~$ sudo wget http://dl.mycat.org.cn/1.6.7.1/Mycat-server-1.6.7.1-release-20200209222254-linux.tar.gz ~$ tar -zxf Mycat-server-1.6.7.1-release-20200209222254-linux.tar.gz -C /usr/local ~$ ls /usr/local/mycat bin catlet conf lib logs version.txt # 设置java路径 ~$ sudo vim /usr/local/mycat/conf/wrapper.conf wrapper.java.command=/usr/local/jdk/bin/java wrapper.startup.timeout=300 # 若启动出错，调整虚拟内存的大小 wrapper.java.additional.9=-Xmx2G wrapper.java.additional.10=-Xms512M # 设置环境变量 ~$ sudo vim /etc/profile.d/mycat.sh MYCAT_HOME=/usr/local/mycat ~$ source /etc/profile MyCat读写分离架构 应用直接连接MyCat的逻辑表testdb,MyCat后端连接真实的MySQL数据库实例，并把写数据和读数据分开，减轻单个MySQL实例的压力。
配置读写分离 配置文件
①schema.xml：定义逻辑库，表、分片节点等内容
②rule.xml：定义分片规则
③server.xml：定义用户以及系统相关变量，如端口等
1、修改配置文件server.xml 修改mycat用户信息，与MySQL区分，如下：
~$ sudo vim /usr/local/mycat/conf/server.xml ...p110 &lt;user name=&#34;root&#34; defaultAccount=&#34;true&#34;&gt; &lt;property name=&#34;password&#34;&gt;mycatpw&lt;/property&gt; &lt;property name=&#34;schemas&#34;&gt;testdb&lt;/property&gt; &lt;property name=&#34;defaultSchema&#34;&gt;testdb&lt;/property&gt; 这里主要设置了MyCat的用户名，密码，逻辑库的name等属性
2、修改配置文件 schema.xml
删除&lt;schema&gt;标签间的表信息，&lt;dataNode&gt;标签只留一个，&lt;dataHost&gt;标签只留一个，&lt;writeHost&gt; &lt;readHost&gt;只留一对
~$ sudo vim /usr/local/mycat/conf/schema.xml &lt;?xml version=&#34;1.0&#34;?&gt; &lt;!DOCTYPE mycat:schema SYSTEM &#34;schema.dtd&#34;&gt; &lt;mycat:schema xmlns:mycat=&#34;http://io.mycat/&#34;&gt; &lt;schema name=&#34;testdb&#34; checkSQLschema=&#34;false&#34; sqlMaxLimit=&#34;100&#34; dataNode=&#34;dn1&#34;&gt; &lt;/schema&gt; &lt;dataNode name=&#34;dn1&#34; dataHost=&#34;host1&#34; database=&#34;test&#34; /&gt; &lt;dataHost name=&#34;host1&#34; maxCon=&#34;1000&#34; minCon=&#34;10&#34; balance=&#34;3&#34; writeType=&#34;0&#34; dbType=&#34;mysql&#34; dbDriver=&#34;native&#34; switchType=&#34;1&#34; slaveThreshold=&#34;100&#34;&gt; &lt;heartbeat&gt;select user()&lt;/heartbeat&gt; &lt;!-- can have multi write hosts --&gt; &lt;writeHost host=&#34;hostM1&#34; url=&#34;10.10.10.11:3306&#34; user=&#34;root&#34; password=&#34;zxcv&#34;&gt; &lt;!-- can have multi read hosts --&gt; &lt;readHost host=&#34;hostS2&#34; url=&#34;10.10.10.12:3306&#34; user=&#34;root&#34; password=&#34;zxcv&#34; /&gt; &lt;/writeHost&gt; &lt;/dataHost&gt; &lt;/mycat:schema&gt; 这里设置数据节点，以及对应的后端真实的MySQL实例属性，写库和读库的属性
dataHost标签中有一个balance属性，用于设置读写分离
balance=&ldquo;0&rdquo;, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上； balance=&ldquo;1&rdquo;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡； balance=&ldquo;2&rdquo;，所有读操作都随机的在 writeHost、readhost 上分发； balance=&ldquo;3&rdquo;，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力 MariaDB数据库账号设置
MariaDB [(none)]&gt; grant all privileges on *.* to root@&#39;%&#39; identified by &#39;zxcv&#39;; Query OK, 0 rows affected (0.00 sec) MariaDB [(none)]&gt; flush privileges; 启动MyCat # 前台启动 ~$ sudo /usr/local/mycat/bin/mycat console # 后台启动 ~$ sudo /usr/local/mycat/bin/mycat start # 查看日志 ~$ sudo tail -f /usr/local/mycat/logs/wrapper.log STATUS | wrapper | 2021/08/04 16:49:51 | --&gt; Wrapper Started as Daemon STATUS | wrapper | 2021/08/04 16:49:51 | Launching a JVM... INFO | jvm 1 | 2021/08/04 16:50:17 | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.org INFO | jvm 1 | 2021/08/04 16:50:17 | Copyright 1999-2006 Tanuki Software, Inc. All Rights Reserve INFO | jvm 1 | 2021/08/04 16:50:17 | INFO | jvm 1 | 2021/08/04 16:50:44 | MyCAT Server startup successfully. see logs in logs/mycat.log 测试MyCat ~$ mysql -h 10.10.10.13 -P 8066 -u root -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \g. Your MySQL connection id is 4 Server version: 5.6.29-mycat-1.6.7.4-release-20200105164103 MyCat Server (OpenCloudDB) Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement. MySQL [(none)]&gt; MySQL [(none)]&gt; show databases; +----------+ | DATABASE | +----------+ | testdb | +----------+ 1 row in set (0.00 sec) 视频教程参考： MyCat性能最好的开源数据库中间件_哔哩哔哩_bilibili ]]></content></entry><entry><title>K8S 集群搭建指南</title><url>/posts/k8s-cluster-guide/</url><categories><category>K8S</category></categories><tags><tag>K8S</tag></tags><content type="html"><![CDATA[
Kubernetes 是一个自动化的容器编排平台，它负责应用的部署、应用的弹性以及应用的管理，本文介绍使用kubeadm搭建 K8S 集群。
环境准备 主机配置 主机名 IP地址 操作系统 配置 Master 10.10.10.60 CentOS7.9 2CPU 2G内存 20G硬盘 Node1 10.10.10.61 CentOS7.9 2CPU 2G内存 20G硬盘 Node2 10.10.10.62 CentOS7.9 2CPU 2G内存 20G硬盘 自行安装Docker
以下环境配置需在三台主机都要执行
关闭selinux setenforce 0 sed -i &#34;s/SELINUX=enforcing/SELINUX=disabled/g&#34; /etc/selinux/config 关闭swap分区或禁用swap文件 $ swapoff -a $ sed -ri &#39;s/.*swap.*/#&amp;/&#39; /etc/fstab # 永久 关闭防火墙 [root@master ~]# systemctl stop firewalld [root@master ~]# systemctl disable firewalld 修改内核参数 $ vim /etc/sysctl.conf net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 $ sysctl -p 启用内核模块 $ vim /etc/sysconfig/modules/ipvs.modules modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 配置hosts $ vim /etc/hosts 10.10.10.60 master 10.10.10.61 node1 10.10.10.62 node2 配置时间同步 # 时间同步 [xdl@k8s-master] ~$ sudo vim /etc/chrony.conf server ntp.aliyun.com iburst [xdl@k8s-master] ~$ sudo systemctl restart chronyd.service 重启系统
安装K8S 配置Kubernets 的yum源 $ vim /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg 安装kubelet、kubeadm、kubectl[v1.21.2] $ yum install -y kubelet kubeadm kubectl # 指定版本 $ yum install -y kubelet-1.20.0 kubeadm-1.20.0 kubectl-1.20.0 启动kubelet服务 $ sudo systemctl enable kubelet $ sudo systemctl start kubelet 设置Docker 修改Docker配置文件 [xdl@k8s-master] ~$ vim /etc/docker/daemon.json { &#34;registry-mirrors&#34;: [ &#34;https://xxxxxxx.mirror.aliyuncs.com&#34; ], &#34;insecure-registries&#34;: [], &#34;exec-opts&#34;: [&#34;native.cgroupdriver=systemd&#34;] } [xdl@k8s-master] ~$ sudo systemctl restart docker.service kubernetes集群初始化 Master节点创建集群（该操作只在master主机执行）
$ sudo kubeadm init \ --kubernetes-version=v1.21.2 \ --image-repository registry.aliyuncs.com/google_containers \ --pod-network-cidr=10.244.0.0/16 \ --service-cidr=10.96.0.0/12 \ --apiserver-advertise-address=10.10.10.60 由于默认拉取镜像地址k8s.gcr.io国内无法访问，这里指定阿里云镜像仓库地址。
如果失败，使用kubeadm reset 重置
[xdl@k8s-master] ~$ mkdir -p $HOME/.kube [xdl@k8s-master] ~$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config [xdl@k8s-master] ~$ sudo chown $(id -u):$(id -g) $HOME/.kube/config node节点加入集群
# node1 [xdl@k8s-node1] ~$ sudo kubeadm join 10.10.10.60:6443 --token tzbczr.r1lmokzaxfnirp73 \ --discovery-token-ca-cert-hash sha256:b9e7a95e7ac84f97c2486ff850b9891c61c32d35d57a8248401f62b97660ea2e # node2 [xdl@k8s-node2] ~$ sudo kubeadm join 10.10.10.60:6443 --token tzbczr.r1lmokzaxfnirp73 \ --discovery-token-ca-cert-hash sha256:b9e7a95e7ac84f97c2486ff850b9891c61c32d35d57a8248401f62b97660ea2e master节点查看node节点信息
[xdl@k8s-master] ~$ kubectl get nodes NAME STATUS ROLES AGE VERSION k8s-master Ready control-plane,master 61m v1.21.2 k8s-node1 Ready &lt;none&gt; 47m v1.21.2 k8s-node2 Ready &lt;none&gt; 46m v1.21.2 kubernetes安装CNI网络插件 kubernetes支持多种网络插件，如：flannel、calico、canal等，任选一种使用即可，本实验选择flannel
只在master节点安装flannel插件即可，该插件使用的是DaemonSet控制器，该控制器会在每个节点上都运行
#获取flannel配置文件 [root@master ~]# wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml #执行文件启动flannel [root@master ~]# kubectl apply -f kube-flannel.yml 等待几分钟，查看状态
[xdl@k8s-master] ~$ kubectl get pods --all-namespaces NAMESPACE NAME READY STATUS RESTARTS AGE kube-system coredns-558bd4d5db-kzvhc 1/1 Running 0 63m kube-system coredns-558bd4d5db-p7x9t 1/1 Running 0 63m kube-system etcd-k8s-master 1/1 Running 0 63m kube-system kube-apiserver-k8s-master 1/1 Running 0 64m kube-system kube-controller-manager-k8s-master 1/1 Running 0 64m kube-system kube-flannel-ds-pfll6 1/1 Running 0 49m kube-system kube-flannel-ds-xfvsn 1/1 Running 0 50m kube-system kube-flannel-ds-xvsst 1/1 Running 0 52m kube-system kube-proxy-9zjlz 1/1 Running 0 50m kube-system kube-proxy-nj8lm 1/1 Running 0 49m kube-system kube-proxy-sqfkx 1/1 Running 0 63m kube-system kube-scheduler-k8s-master 1/1 Running 0 63m 全部显示running则说明搭建成功了。
测试Kubernets 集群 在Kubernetes集群中创建一个pod，验证是否正常运行：
[xdl@k8s-master] ~$ kubectl create deployment nginx --image=nginx deployment.apps/nginx created [xdl@k8s-master] ~$ kubectl expose deployment nginx --port=80 --type=NodePort service/nginx exposed [xdl@k8s-master] ~$ kubectl get pods,svc NAME READY STATUS RESTARTS AGE pod/nginx-6799fc88d8-5982c 1/1 Running 0 73s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 14h service/nginx NodePort 10.104.158.32 &lt;none&gt; 80:32389/TCP 20s # 测试 [xdl@k8s-master] ~$ curl -I node1:32389 HTTP/1.1 200 OK Server: nginx/1.21.1 参考链接： K8S安装过程笔记 | 鸿则的博客 (hungtcs.top) Kubernetes/K8S 集群环境搭建_哔哩哔哩_bilibili Kubernetes ]]></content></entry><entry><title>MooseFS网络分布式文件系统指南</title><url>/posts/moosefs-guide/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[
MooseFS是一个具备冗余容错功能、高可用、高性能、可扩展的网络分布式文件系统，它将数据分别存放在多个物理服务器或一个服务器的多块磁盘，确保一份数据有多个备份副本，然而对于访问MFS的客户端或者用户来说，整个网络分布式文件系统集群看起来就像一个虚拟磁盘一样。MooseFS分为普通版和Pro版本，Pro版本需要授权。
MooseFS 特性 a.高可靠性：每一份数据可以设置多个备份（多分数据），并可以存储在不同的主机上
b.高可扩展性：可以很轻松的通过增加主机的磁盘容量或增加主机数量来动态扩展整个文件系统的存储量
c.高可容错性：我们可以通过对mfs进行系统设置，实现当数据文件被删除后的一段时间内，依旧存放于主机的回收站中，以备误删除恢复数据
d.高数据一致性：即使文件被写入、访问时，我们依然可以轻松完成对文件的一致性快照；
MooseFS 应用场景 大规模高并发的线上数据存储及访问（小文件，大文件都适合）
大规模的数据处理，如日志分析，小文件强调性能不用HDFS
MooseFS 组成 管理服务器 (master server) 简称 master ：
这个组件的角色是管理整个mfs文件系统的主服务器，除了分发用户请求外，还用来存储整个文件系统中每个数据文件的metadata信息，metadate（元数据）信息包括文件（也可以是目录，socket，管道，块设备等）的大小，属性，文件的位置路径等。
云数据备份服务器 (Metadata backup servers) 简称 metalogger：
这个组件的作用是备份管理服务器master的变化的metadata信息日志文件，文件类型为changelog_ml.*.mfs。以便于在管理服务器出问题时，可以经过简单的操作即可让新的主服务器进行工作。
数据存储服务器组（chunk servers）简称data：
这个组件就是真正存放数据文件实体的服务器了，这个角色可以有多台不同的物理服务器或不同的磁盘及分区来充当，当配置数据的副本多于一份时，据写入到一个数据服务器后，会根据算法在其他数据服务器上进行同步备份。
客户机服务器组（client servers）简称 client：
这个组件就是挂载并使用mfs文件系统的客户端，当读写文件时，客户端首先会连接主管理服务器获取数据的metadata信息，然后根据得到的metadata信息，访问数据服务器读取或写入文件实体，mfs客户端通过fuse mechanism实现挂载mfs文件系统的，因此，只有系统支持fuse，就可以作为客户端访问mfs整个文件系统。
MooseFS 原理 Master记录着管理信息，比如：文件路径|大小|存储的位置(ip,port,chunkid)|份数|时间等，元数据信息存在于内存中，会定期写入metadata.mfs.back文件中，定期同步到metalogger，操作实时写入changelog.*.mfs，实时同步到metalogger中。master启动将metadata.mfs载入内存，重命名为metadata.mfs.back文件。
文件以chunk大小存储，每chunk最大为64M，小于64M的，该chunk的大小即为该文件大小（验证实际chunk文件略大于实际文件），超过64M的文件将被切分，以每一份（chunk）的大小不超过64M为原则；块的生成遵循规则：目录循环写入(00-FF 256个目录循环，step为2)、chunk文件递增生成、大文件切分目录连续。
Chunkserver上的剩余存储空间要大于1GB（Reference Guide有提到），新的数据才会被允许写入，否则，你会看到No space left on device的提示
文件可以有多份copy，当goal为1时，文件会被随机存到一台chunkserver上，当goal的数大于1时，copy会由master调度保存到不同的chunkserver上，goal的大小不要超过chunkserver的数量，否则多出的copy，不会有chunkserver去存。
MooseFS 集群搭建 实验架构图 环境准备 操作系统：CentOS7 MooseFS版本：3.0.115 chunk servers 加入 5G 的磁盘 以下步骤在所有节点操作
1. 配置MooseFS软件源 # 导入验证密钥 curl &#34;https://ppa.moosefs.com/RPM-GPG-KEY-MooseFS&#34; &gt; /etc/pki/rpm-gpg/RPM-GPG-KEY-MooseFS # 添加yum 源 # For CentOS8 $ curl &#34;http://ppa.moosefs.com/MooseFS-3-el8.repo&#34; &gt; /etc/yum.repos.d/MooseFS.repo # For CentOS7 $ curl &#34;http://ppa.moosefs.com/MooseFS-3-el7.repo&#34; &gt; /etc/yum.repos.d/MooseFS.repo # For CentOS6 $ curl &#34;http://ppa.moosefs.com/MooseFS-3-el6.repo&#34; &gt; /etc/yum.repos.d/MooseFS.repo 2. 配置解析 # 所有节点 [root@CentOS] ~$ echo &#39;10.10.10.11 mfsmaster&#39; &gt;&gt; /etc/hosts 搭建步骤 Master Server $ yum install moosefs-master moosefs-cgi moosefs-cgiserv moosefs-cli [root@CentOS] ~$ vim /etc/mfs/mfsexports.cfg 10.10.10.0/24 / rw,alldirs,maproot=0 # · 表示MFS文件系统 # rw,alldirs,maproot=0 表示客户端拥有的权限 # rw 读写方式分享 # alldirs 允许挂载任何指定的子目录 # maproot 映射为root用户还是指定的用户，为0则不映射 # password 指定客户端密码 # 修改master server 配置文件 [root@CentOS] ~$ vim /etc/mfs/mfsmaster.cfg WORKING_USER = mfs WORKING_GROUP = mfs SYSLOG_IDENT = mfsmaster DATA_PATH = /var/lib/mfs EXPORTS_FILENAME = /etc/mfs/mfsexports.cfg # 启动服务 [root@CentOS] ~$ systemctl enable --now moosefs-master.service # 配置MooseFS CGI Server # MooseFS CGI 监控接口用于观察和分析 MooseFS 当前的状态 [root@CentOS] ~$ systemctl enable --now moosefs-cgiserv.service [root@CentOS] ~$ netstat -antpl |grep 9425 tcp 0 0 0.0.0.0:9425 0.0.0.0:* LISTEN 2703/python2 # 浏览器访问 firefox http://10.10.10.11:9425 Metadata backup servers (Metaloggers) 元数据备份节点配置
$ yum install moosefs-metalogger [root@CentOS] ~$ vim /etc/mfs/mfsmetalogger.cfg WORKING_USER = mfs WORKING_GROUP = mfs SYSLOG_IDENT = mfsmetalogger DATA_PATH = /var/lib/mfs BIND_HOST = 10.10.10.12 MASTER_HOST = mfsmaster MASTER_PORT = 9419 # 启动服务 [root@CentOS] ~$ systemctl enable --now moosefs-metalogger.service [root@CentOS] ~$ netstat -antpl |grep mfs tcp 0 0 10.10.10.12:42183 10.10.10.11:9419 ESTABLISHED 2384/mfsmetalogger Chunkservers配置 ① 磁盘设置
每台 chunkserver 上添加一块5G的磁盘
# 分区 [root@CentOS] ~$ parted --align optimal /dev/sdb GNU Parted 3.1 使用 /dev/sdb Welcome to GNU Parted! Type &#39;help&#39; to view a list of commands. (parted) mklabel gpt (parted) mkpart mfschunks1 0% 100% (parted) q 信息: You may need to update /etc/fstab. # 格式化 [root@CentOS] ~$ mkfs -t xfs /dev/sdb1 # 挂载 [root@CentOS] ~$ mkdir /mnt/mfschunks1 [root@CentOS] ~$ [root@CentOS] ~$ mount /mnt/mfschunks1 [root@CentOS] ~$ chown mfs.mfs /mnt/mfschunks1 [root@CentOS] ~$ chmod 770 /mnt/mfschunks1 # 设置开机自动挂载 [root@CentOS] ~$ vim /etc/fstab /dev/sdb1 /mnt/mfschunks1 xfs defaults 0 0 ② chunk 服务设置
# 安装软件包 $ yum install moosefs-chunkserver # 修改配置文件 [root@CentOS] ~$ vim /etc/mfs/mfschunkserver.cfg WORKING_USER = mfs WORKING_GROUP = mfs SYSLOG_IDENT = mfschunkserver DATA_PATH = /var/lib/mfs HDD_CONF_FILENAME = /etc/mfs/mfshdd.cfg LABELS = chunkserver1 BIND_HOST = 10.10.10.13 MASTER_HOST = mfsmaster MASTER_PORT = 9420 # 修改挂载的磁盘配置 [root@CentOS] ~$ vim /etc/mfs/mfshdd.cfg /mnt/mfschunks1 # 启动服务，不能手动挂载 mount -a [root@CentOS] ~$ systemctl enable --now moosefs-chunkserver.service [root@CentOS] ~$ netstat -antpl |grep mfs tcp 0 0 0.0.0.0:9422 0.0.0.0:* LISTEN 2070/mfschunkserver tcp 0 0 10.10.10.13:38923 10.10.10.11:9420 ESTABLISHED 2070/mfschunkserver Client客户端设置 $ yum install fuse libfuse2 $ yum install moosefs-client # 挂载MFS文件系统 [root@dev ~]# mkdir -p /mnt/mfs [root@dev ~]# mfsmount /mnt/mfs/ -H mfsmaster mfsmaster accepted connection with parameters: read-write,restricted_ip,admin ; root mapped to root:root # 查看挂载的情况 [root@dev ~]# df -h |grep mfs mfsmaster:9421 10G 577M 9.5G 6% /mnt/mfs 测试 在客户端新建目录folder1 ，设置目录有一份拷贝（goal=1）,新建目录folder2 ，设置目录有一份拷贝（goal=2）
[root@dev ~]# mkdir -p /mnt/mfs/folder1 [root@dev ~]# mkdir -p /mnt/mfs/folder2 [root@dev ~]# mfssetgoal -r 1 /mnt/mfs/folder1 /mnt/mfs/folder1: inodes with goal changed: 1 inodes with goal not changed: 0 inodes with permission denied: 0 [root@dev ~]# mfssetgoal -r 2 /mnt/mfs/folder2 /mnt/mfs/folder2: inodes with goal changed: 0 inodes with goal not changed: 1 inodes with permission denied: 0 注意：副本的数量不能超过chunk server的数量。
新建文件测试，查看文件的副本信息
[root@dev ~]# echo &#39;Hello MFS!&#39; &gt; test.txt [root@dev ~]# cp test.txt /mnt/mfs/folder1 [root@dev ~]# cp test.txt /mnt/mfs/folder2 [root@dev ~]# mfscheckfile /mnt/mfs/folder1/test.txt /mnt/mfs/folder1/test.txt: chunks with 1 copy: 1 # &lt;---- one copy [root@dev ~]# mfscheckfile /mnt/mfs/folder2/test.txt /mnt/mfs/folder2/test.txt: chunks with 2 copies: 1 # &lt;---- two copies 安全的停止MooseFS集群 客户端卸载所有的挂载点 [root@dev ~] $ lsof -n |grep mfsmount [root@dev ~] $ umount /mnt/mfs 停止 Chunkserver 服务 [root@CentOS] ~$ systemctl stop moosefs-chunkserver.service 停止 Master Server 服务 [root@CentOS] ~$ systemctl stop moosefs-master.service 停止 Metalogger 服务 [root@CentOS] ~$ systemctl stop moosefs-metalogger.service 参考：
MooseFS官网 ]]></content></entry><entry><title>Ceph 分布式文件系统简介</title><url>/posts/cephfs-info/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html">
Ceph 是一种使用广泛的分布式文件系统
存储分类 本地文件系统 ntfs(wind)、ext2、ext3、ext4、xfs
ext2不带日志，3和4带有日志：文件系统的日志作用（防止机器突然断电）：所有的数据在给磁盘存数据之前会先给文件系统的日志里面存一份，防止机器突然断电之后数据没有存完，这样它还可以从日志里面重新将数据拷贝到磁盘。
网络文件系统 nfs 网络文件系统&amp;ndash;称之为nas存储（网络附加存储）
分布式文件系统 hdfs 分布式网络文件系统
glusterfs 分布式网络文件系统，不需要管理服务器
ceph 分布式网络文件系统，块存储，对象存储
分布式文件系统架构 client | namenode | ------------------------------------ | | | datanode datanode datanode namenode 元数据服务器-管理服务器，存储这个文件的数据存放的位置信息
datanode 存储数据，数据节点
分布式文件系统的特性 可扩展
分布式存储系统可以扩展到几百台甚至几千台的集群规模，而且随着集群规模的增长，系统整体性能表现为线性增长。分布式存储的水平扩展有以下几个特性：
节点扩展后，旧数据会自动迁移到新节点，实现负载均衡，避免单点故障的情况出现;
水平扩展只需要将新节点和原有集群连接到同一网络，整个过程不会对业务造成影响;
低成本
分布式存储系统的自动容错、自动负载均衡机制使其可以构建在普通的PC机之上。
易管理
可通过一个简单的WEB界面就可以对整个系统进行配置管理，运维简便，极低的管理成本。
块存储的特点： 1.主要是将裸磁盘空间映射给主机使用的，共享的最小单位是块
2.使用的交换机是光纤交换机价格贵成本高
3.性能最好，扩展性好
4.不能做文件系统的共享
最典型的就是SAN（storage area network）(存储区域网)&amp;mdash;-有一个局域网里面有一个交换机， 交换机上面连着服务器，所有服务器都是专业存储的设备，他们组成一个存储区域网，当我们用的时候只需要在 这个区域网里面拿空间使用
对象存储 为什么需要对象存储？ 首先，一个文件包含了属性（术语叫metadata，元数据，例如该文件的大小、修改时间、存储路径等）以及内容（以下简称数据）。
而对象存储则将元数据独立了出来，控制节点叫元数据服务器（服务器+对象存储管理软件），里面主要负责存储对象的属性（主要是对象的数据被打散存放到了那几台分布式服务器中的信息），而其他负责存储数据的分布式服务器叫做OSD，主要负责存储文件的数据部分。当用户访问对象，会先访问元数据服务器，元数据服务器只负责反馈对象存储在哪些OSD，假设反馈文件A存储在B、C、D三台OSD， 那么用户就会再次直接访问3台OSD服务器去读取数据。
由于是3台OSD同时对外传输数据，所以传输的速度就加快了。当OSD服务器数量越多，这种读写速度的提升就越大，通过此种方式，实现了读写快的目的。
另一方面，对象存储软件是有专门的文件系统的，所以OSD对外又相当于文件服务器，那么就不存在文件共享方面的困难了，也解决了文件共享方面的问题。
#所以对象存储的出现，很好地结合了块存储与文件存储的优点。
优点： 具备块存储的读写高速。
具备文件存储的共享等特性。
使用场景： (适合更新变动较少的数据) 图片存储。
视频存储。</content></entry><entry><title>Linux配置Tinyproxy代理</title><url>/posts/linux-tinyproxy-config/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[Tinyproxy是一个轻量级的http代理软件，速度快体积小，可以使用来把socks5代理转为http代理。测试环境为 &#x1f525; ArchLinux,IP:172.16.10.18,Socks5端口1090.
查询软件包 ~$ pacman -Ss tinyproxy community/tinyproxy 1.10.0-2 [已安装] A light-weight HTTP proxy daemon for POSIX operating systems. 安装tinyproxy ~$ sudo pacman -Sy tinyproxy 修改配置文件 ~$ vim /etc/tinyproxy/tinyproxy.conf User tinyproxy Group tinyproxy Port 8888 Listen 0.0.0.0 Timeout 600 ErrorFile 404 &#34;/usr/share/tinyproxy/404.html&#34; ErrorFile 400 &#34;/usr/share/tinyproxy/400.html&#34; ErrorFile 503 &#34;/usr/share/tinyproxy/503.html&#34; ErrorFile 403 &#34;/usr/share/tinyproxy/403.html&#34; DefaultErrorFile &#34;/usr/share/tinyproxy/default.html&#34; StatFile &#34;/usr/share/tinyproxy/stats.html&#34; LogFile &#34;/var/log/tinyproxy/tinyproxy.log&#34; #关闭syslog，使用自定义的日志文件 #Syslog On LogLevel Info PidFile &#34;/var/run/tinyproxy/tinyproxy.pid&#34; # 在请求头中加入客户端IP #XTinyproxy Yes #设置上游代理，转换上游socks5代理为http代理 upstream socks5 127.0.0.1:1090 MaxClients 100 MinSpareServers 5 MaxSpareServers 20 StartServers 10 MaxRequestsPerChild 0 # 允许局域网的哪些主机访问 Allow 172.16.10.0/24 Allow 192.168.1.0/24 AddHeader &#34;X-My-Header&#34; &#34;Powered by Tinyproxy&#34; ViaProxyName &#34;tinyproxy&#34; 启动服务 ~$ sudo systemctl start tinyproxy.service ~$ sudo systemctl enable tinyproxy.service 测试 在局域网内的其它主机上把代理设置为上面的Tinyproxy,测试请求头信息
xdl@aml:~$ export http_proxy=&#39;http://172.16.10.18:8888&#39; xdl@aml:~$ export https_proxy=&#39;http://172.16.10.18:8888&#39; xdl@aml:~$ curl -I www.baidu.com HTTP/1.0 200 OK Via: 1.1 tinyproxy (tinyproxy/1.10.0) # &lt;------ 请求头中包含了Tinyproxy Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Content-Type: text/html Etag: &#34;575e1f6f-115&#34; Last-Modified: Mon, 13 Jun 2016 02:50:23 GMT Pragma: no-cache Server: bfe/1.0.8.18 Accept-Ranges: bytes Date: Thu, 20 Aug 2020 06:57:01 GMT Content-Length: 277 参考： 1. https://tinyproxy.github.io/ 2. https://github.com/tinyproxy/tinyproxy 3. https://linux.cn/article-7119-1.html ]]></content></entry><entry><title>Ceph 分布式系统搭建</title><url>/posts/cephfs-setup/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[
上一篇介绍了Ceph分布式文件系统，下面介绍Ceph分布式文件系统的安装配置和使用
一、环境准备 1. 环境说明 操作系统：CentOS Linux 7 node[1-3]添加一块5G的磁盘 Ceph 版本：nautilus 主机名 IP地址 用途 admin 10.10.10.60 管理节点 安装ceph-deploy node1 10.10.10.61 mon mgr osd node2 10.10.10.62 osd node3 10.10.10.63 osd client 10.10.10.64 client测试 2.配置相应的环境 以下操作在所有节点配置
2.1 新建用户
## all [xdl@admin] ~$ sudo useradd -G wheel ceph [xdl@admin] ~$ echo &#39;ceph&#39; |sudo passwd --stdin ceph 2.2 修改hosts
[ceph@admin ~]$ sudo vim /etc/hosts # Ceph 10.10.10.60 admin 10.10.10.61 node1 10.10.10.62 node2 10.10.10.63 node3 10.10.10.64 client 2.3 配置时间同步
[root@admin] ~$ vim /etc/chrony.conf server ntp.aliyun.com iburst [root@admin] ~$ systemctl restart chronyd.service [root@admin] ~$ chronyc sources -v 2.4 配置admin节点与各node节点的ssh免密登录
## admin [xdl@admin] ~$ su - ceph [ceph@admin ~]$ ssh-keygen -t rsa -b 1024 [ceph@admin ~]$ ssh-copy-id ceph@node1 [ceph@admin ~]$ ssh-copy-id ceph@node2 [ceph@admin ~]$ ssh-copy-id ceph@node3 2.5 配置ceph 软件源
[root@node1] ~$ vim /etc/yum.repos.d/ceph.repo [ceph] name=Ceph packages for $basearch baseurl=https://mirrors.cloud.tencent.com/ceph/rpm-nautilus/el7/$basearch enabled=1 priority=2 gpgcheck=1 gpgkey=https://mirrors.cloud.tencent.com/ceph/keys/release.asc [ceph-noarch] name=Ceph noarch packages baseurl=https://mirrors.cloud.tencent.com/ceph/rpm-nautilus/el7/noarch enabled=1 priority=2 gpgcheck=1 gpgkey=https://mirrors.cloud.tencent.com/ceph/keys/release.asc [ceph-source] name=Ceph source packages baseurl=https://mirrors.cloud.tencent.com/ceph/rpm-nautilus/el7/SRPMS enabled=0 priority=2 gpgcheck=1 gpgkey=https://mirrors.cloud.tencent.com/ceph/keys/release.as [root@node1] ~$ yum makecache 二、安装配置 admin管理节点配置 安装ceph-deploy [root@admin] ~$ yum search ceph [root@admin] ~$ yum install -y ceph-deploy python-setuptools 创建节点node1 [root@admin] ~$ su - ceph [ceph@admin ~]$ mkdir cluster [ceph@admin ~]$ cd cluster/ [ceph@admin cluster]$ ceph-deploy new node1 [ceph@admin cluster]$ ls ceph.conf ceph-deploy-ceph.log ceph.mon.keyring node1节点配置 安装软件包 [root@node1] ~$ yum makecache [root@node1] ~$ yum install -y ceph ceph-radosgw [root@node1] ~$ ceph --version ceph version 14.2.16 (762032d6f509d5e7ee7dc008d80fe9c87086603c) nautilus (stable) 配置mon 和 mgr # 初始化mon; admin节点以ceph用户执行 [ceph@admin cluster]$ ceph-deploy mon create-initial # 赋予各个节点使用命令免密码权限 [ceph@admin cluster]$ ceph-deploy admin node1 node2 node3 # 安装ceph-mgr,只有luminous源才有，为dashboard做准备 [ceph@admin cluster]$ ceph-deploy mgr create node1 添加osd 各个节点提供的存储空间不能太小，最好5G以上, /dev/sdb 是为osd 准备的空闲磁盘（无需格式化）
[ceph@admin cluster]$ ceph-deploy osd create --data /dev/sdb node1 [ceph@admin cluster]$ ceph-deploy osd create --data /dev/sdb node2 [ceph@admin cluster]$ ceph-deploy osd create --data /dev/sdb node3 # 查看 [ceph@admin cluster]$ ssh node1 lsblk -f 查看ceph 的状态 [ceph@admin cluster]$ ssh node1 sudo ceph -s Dashboard配置 创建node1管理密钥 [ceph@node1 ~]$ sudo ceph auth get-or-create mgr.node1 mon &#39;allow profile mgr&#39; osd &#39;allow *&#39; mds &#39;allow *&#39; [mgr.node1] key = AQB2RAVgLC29BhAABkyYcjDyrjShJ1C9N2hlaQ== 开启ceph-mgr 管理域 [ceph@node1 ~]$ sudo ceph-mgr -i node1 查看ceph 的状态，确认mgr 的状态为 active [ceph@node1 ~]$ sudo ceph status 打开 dashboard 模块 [ceph@node1 ~]$ sudo ceph mgr module enable dashboard 绑定开启dashboard 模块的 ceph-mgr 节点的IP地址 [ceph@node1 ~]$ sudo ceph config-key set mgr/dashboard/node1/server_addr 10.10.10.61 set mgr/dashboard/node1/server_addr 查看监听端口 [ceph@node1 ~]$ sudo netstat -antp |grep 7000 tcp 0 0 10.10.10.61:7000 0.0.0.0:* LISTEN 12994/ceph-mgr 浏览器访问： http://10.10.10.61:7000
客户端的使用 客户端需要更新内核版本到4.x以上
[xdl@client] ~$ uname -r 5.10.8-1.el7.elrepo.x86_64 安装软件 [root@client] ~$ yum makecache [root@client] ~$ yum install -y python-setuptools [root@client] ~$ su - ceph [ceph@client ~]$ sudo yum install -y ceph ceph-radosgw [ceph@client ~]$ ceph --version ceph version 14.2.16 (762032d6f509d5e7ee7dc008d80fe9c87086603c) nautilus (stable) 在admin节点赋予client使用命令免权限 [ceph@admin cluster]$ ceph-deploy admin client 修改client下该文件呢的读权限 [ceph@client ~]$ sudo chmod +r /etc/ceph/ceph.client.admin.keyring 修改client 的ceph 配置文件，这一步是解决映射镜像时出错问题 [ceph@client ~]$ sudo vim /etc/ceph/ceph.conf [global] rbd_default_features = 1 client 节点创建块设备镜像，单位为MB [ceph@client ~]$ rbd create foo --size 4096 client 节点映射镜像到主机 [ceph@client ~]$ sudo rbd map foo --name client.admin /dev/rbd0 client 节点格式化块设备 [ceph@client ~]$ sudo mkfs -t ext4 -m 0 /dev/rbd/rbd/foo client 节点挂载块设备 [ceph@client ~]$ sudo mkdir /mnt/ceph [ceph@client ~]$ sudo mount /dev/rbd/rbd/foo /mnt/ceph/ [ceph@client ~]$ df -lhT 文件系统 类型 容量 已用 可用 已用% 挂载点 /dev/rbd0 ext4 3.9G 16M 3.8G 1% /mnt/ceph 客户端重启后，设备需要重新做映射（6），不然会卡死
测试 [ceph@client ~]$ cd /mnt/ceph/ [ceph@client ceph]$ sudo touch test.txt [ceph@client ceph]$ ls lost+found test.txt ]]></content></entry><entry><title>我的 vim 配置文件</title><url>/posts/my-vimrc-backup/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>vim</tag></tags><content type="html"><![CDATA[
我常用到的vim配置文件备份，纯vim配置，不包含任何插件，做一个记录备份，方便多系统迁移使用。
安装vim # CentOS ~$ sudo yum install -y vim # Debian/Ubuntu ~$ sudo apt install -y vim # Arch Linux ~$ sudo pacman -Sy vim 配置文件 Debian/Ubuntu 放在/etc/vim/vimrc.local下用于全局配置，对所有用户都生效
放在~/.vimrc只对当前登录用户生效。
~$ vim ~/.vimrc &#34;开启语法高亮 syntax on &#34; 检测文件类型 filetype on &#34; 设置在Vim中可以使用鼠标，防止终端无法拷贝 if has(&#39;mouse&#39;) set mouse-=a endif &#34; 显示当前行号和列号 set ruler &#34; 在状态栏显示正在输入的命令 set showcmd &#34; 左下角显示当前Vim模式 set showmode &#34; 括号匹配模式 set showmatch &#34; 显示行号 set number &#34; 设置tab宽度 set tabstop=4 &#34; 设置自动对齐空格数 set shiftwidth=4 &#34;设置（软）制表符宽度为4 set softtabstop=4 &#34; 用space替代tab的输入 set expandtab &#34;不用space替代tab的输入 &#34; set noexpandtab &#34; 智能自动缩进 set smartindent &#34; 自动对齐 set autoindent &#34; 设置编码方式 set encoding=utf-8 set helplang=cn set magic set cursorline &#34; 搜索相关 set hlsearch set incsearch &#34;不要备份文件 set nobackup 参考链接 1. vim教程网 2. vim官网 ]]></content></entry><entry><title>使用 Docker buildx 构建多架构镜像</title><url>/posts/docker-buildx-multi-arch-images/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag><tag>Linux</tag></tags><content type="html"><![CDATA[
Docker Buildx 是一个 docker CLI 插件，其扩展了 docker 命令，支持 Moby BuildKit 提供的功能。提供了与 docker build 相同的用户体验，并增加了许多新功能。
1.简介 BuildKit 是下一代的镜像构建组件，主要特点有很多，本文主要使用其可以编译多种系统架构的特性。 网址：https://github.com/moby/buildkit 需要注意的是，该功能仅适用于 Docker v19.03+ 版本。
本文将讲解如何使用 Buildx 构建多种系统架构的镜像。 在开始之前，已经默认你在 Linux 系统（各大发行版）下安装好了 64 位的 Docker，我的测试环境为Linux amd64Ubuntu20.04.
2.开始实验性功能 ~$ vim /etc/docker/daemon.json { &#34;experimental&#34;: true } # 重启docker使配置生效 ~$ sudo systemctl restart docker.service ~$ docker version Server: Docker Engine - Community Engine: Version: 20.10.1 API version: 1.41 (minimum version 1.12) Go version: go1.13.15 Git commit: f001486 Built: Tue Dec 15 04:35:42 2020 OS/Arch: linux/amd64 Experimental: true # &lt;--------开启成功 2.安装跨平台编译环境依赖支持 ~$ apt install qemu binfmt-support qemu-user-static 3.安装buildx 在最新的Docker 20.10.1+ 版本中已默认安装buildx，低于这个版本则手动安装
下载地址： https://github.com/docker/buildx/releases/ xdl@ubuntu20:~$ mkdir -p ~/.docker/cli-plugins xdl@ubuntu20:~$ mv buildx-v0.4.1.linux-amd64 .docker/cli-plugins/docker-buildx xdl@ubuntu20:~$ chmod a+x ~/.docker/cli-plugins/docker-buildx 4.准备环境 xdl@ubuntu20:~$ docker buildx ls NAME/NODE DRIVER/ENDPOINT STATUS PLATFORMS default * docker default default running linux/amd64, linux/386 xdl@ubuntu20:~$ docker buildx create --name mybuilder \ --platform linux/arm,linux/arm64,linux/amd64 mybuilder xdl@ubuntu20:~$ docker buildx use mybuilder xdl@ubuntu20:~$ docker buildx inspect Name: mybuilder Driver: docker-container Nodes: Name: mybuilder0 Endpoint: unix:///var/run/docker.sock Status: inactive # &lt;------- 未运行 Platforms: linux/arm/v7*, linux/arm64*, linux/amd64* $ docker buildx inspect --bootstrap [+] Building 3.5s (1/1) FINISHED =&gt; [internal] booting buildkit 3.5s =&gt; =&gt; pulling image moby/buildkit:buildx-stable-1 3.2s =&gt; =&gt; creating container buildx_buildkit_mybuilder0 0.4s Name: mybuilder Driver: docker-container Nodes: Name: mybuilder0 Endpoint: unix:///var/run/docker.sock Status: running # &lt;-------- 运行状态 Platforms: linux/arm/v7*, linux/arm64*, linux/amd64*, linux/386 5.登录Docker Hub # 登录 DockerHub 便于push images ~$ docker login 6.编译示例 下面使用Trojan源码编译适用多CPU架构的 docker 镜像，系统配置越高编译越开，需要设置科学上网环境或者在国外的VPS上编译。由于我常使用的CPU架构有 armv7,arm64,amd64,其它的可自己添加，我就只编译这三种架构的镜像。
# 下载最新Trojan源码 $ wget https://github.com/trojan-gfw/trojan/archive/v1.16.0.zip $ unzip *.zip $ cd trojan # 加入自定义的设置 $ vim Dockerfile $ docker buildx build --platform linux/arm,linux/arm64,linux/amd64 \ -t pengshp/trojan:v1.16 . --push &ndash;platform 指定要编译的CPU架构
&ndash;push 编译完后上传到 Docker Hub
参考链接 1. 使用 Docker Buildx 构建多种系统架构镜像 2. Github buildx 3. Docker buildx ]]></content></entry><entry><title>Linux VPS 开启 bbr 加速和fastopen</title><url>/posts/linux-bbr-speed/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>VPS</tag></tags><content type="html">
TCP BBR 是由 Google 设计，于2016年发布的拥塞算法，可以降低 TCP 握手的延迟时间，加快 VPS 代理的速度，本文介绍如何在 VPS上开启 bbr,并打开tcp_fastopen
1.bbr简介 TCP BBR（Bottleneck Bandwidth and Round-trip propagation time）是由Google设计，于2016年发布的拥塞算法。以往大部分拥塞算法是基于丢包来作为降低传输速率的信号，而BBR则基于模型主动探测。该算法使用网络最近出站数据分组当时的最大带宽和往返时间来创建网络的显式模型。数据包传输的每个累积或选择性确认用于生成记录在数据包传输过程和确认返回期间的时间内所传送数据量的采样率。该算法认为随着网络接口控制器逐渐进入千兆速度时，分组丢失不应该被认为是识别拥塞的主要决定因素，所以基于模型的拥塞控制算法能有更高的吞吐量和更低的延迟，可以用BBR来替代其他流行的拥塞算法，例如CUBIC。Google在YouTube上应用该算法，将全球平均的YouTube网络吞吐量提高了4%，在一些国家超过了14%。
BBR之后移植入Linux内核4.9版本，并且对于QUIC可用。
BBR 目的是要尽量跑满带宽，并且尽量不要有排队的情况，效果并不比速锐差。
Linux kernel 4.9+ 已支持 tcp_bbr。下面简单讲述基于 KVM 架构 VPS 如何开启。
2.查看Linux内核版本 [xdl@vultr ~]$ uname -r 5.2.2-1.el7.elrepo.x86_64 3.开启bbr加速 [xdl@vultr ~]$ sudo vim /etc/sysctl.d/bbr.conf net.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr 4.重新加载配置 [xdl@vultr ~]$ sudo sysctl -p net.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr 5.测试是否生效 [xdl@vultr ~]$ lsmod | grep bbr tcp_bbr 20480 246 6.检查tcp_fastopen TCP fast open 集成到了Linux kernel3.7,并且在3.13的内核中默认开启，使用uname -r可查看当前系统的内核版本。或者使用下面的命令检查
[xdl@vultr ~]$ cat /proc/sys/net/ipv4/tcp_fastopen 1 It can return 4 values.
0 means disabled. 1 means it’s enabled for outgoing connection (as a client). 2 means it’s enabled for incoming connection (as a server). 3 means it’s enabled for both outgoing and incoming connection. 7.开启fast open 由于我们的VPS 是作为server 使用，可以设置为3，对流入和流出的流量都生效。在LAN客户端可以使用默认1便可。
[xdl@vultr ~]$ sudo vim /etc/sysctl.d/bbr.conf net.ipv4.tcp_fastopen=3 # 重载配置 [xdl@vultr ~]$ sudo sysctl -f /etc/sysctl.d/bbr.conf net.core.default_qdisc=fq net.ipv4.tcp_congestion_control=bbr net.ipv4.tcp_fastopen=3 如果系统内核低的可以使用下面链接的一键开启bbr加速脚本，也会安装最新你的内核。支持CentOS6+，Debian8+，Ubuntu16+
参考链接
How to Install Shadowsocks-Libev Proxy Server on Debian 10 VPS 一键安装最新内核并开启 BBR 脚本</content></entry><entry><title>使用 OpenSSL 自签名 TLS/SSL 证书</title><url>/posts/openssl-https/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html">有时需要一个本地的自签名证书，便于本地的加密https 访问，或者用于开发和测试，OpenSSL 便可以方便自签名一个证书，下面介绍使用方法。
证书的工作原理 你使用自己的证书请求文件 server.csr向证书签发机构CA如：Verisign、GoDaddy 请求证书，证书签发机构使用它们的root根证书和私钥根据你提供的证书请求文件签发你需要的证书server.crt,所有的浏览器或者操作系统中都有一份证书签发机构的root根证书拷贝，当访问你的证书签发的域名时，会使用签发机构的root证书验证你的域名对应证书的有效性。
自签名TLS/SSL证书过程：OpenSSL 生成一个私钥server.key，使用私钥生成证书请求文件server.csr,再使用server.key 和 server.csr 生成证书文件server.crt
1、安装OpenSSL # Debian ~$ sudo apt install -y openssl # CentOS ~$ sudo yum install -y openssl # 查看版本 ~$ openssl version OpenSSL 1.1.1g 21 Apr 2020 2、生成CSR证书请求文件和私钥 使用秋水逸冰大佬制作的网站在线生成,点击 https://www.csr.sh/ 域名可以填写泛域名，这样可以匹配www.alarmpi.lan,dl.alarmpi.lan
点击生成CSR，复制出来用编辑器打开，分两部分，上半部分为证书的请求文件，下半部分为私钥，分别保存为server.csr,server.key
openssl$ ls server.csr server.key 3、使用OpenSSL生成服务证书 ~$ openssl x509 -req -days 3650 -in server.csr -signkey server.key -out server.crt Signature ok subject=C = CN, CN = *.alarmpi.lan, L = Guangzhou, O = RaspberryPi, ST = Guangdong, OU = IT Getting Private key ~$ $ ls server.crt server.csr server.key -days指定证书的有效期，这个证书的有效期为10年。
4、验证证书的有效性 ~$ openssl verify server.crt 如果要你的浏览器或操作系统信任你的自签名证书，即访问时不再有警告提示，需要你把用于签发证书的root根证书导入到浏览器或者操作系统的受信任的证书签发机构域。
参考链接 1、 How to create &amp;amp; sign SSL/TLS certificates 2、 OpenSSL command cheatsheet 3、 生成证书的命令行工具</content></entry><entry><title>CentOS 防火墙 firewalld 的管理</title><url>/posts/centos-firewall-manage/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag></tags><content type="html">
CentOS7.x 使用firewalld 防火墙替代了 CentOS6.x 中的 iptables,两者的使用上有较大的区别，本文介绍firewall在日常的使用和管理中常使用的一些基本命令。
一、firewall基本管理 # 开启防火墙服务 $ sudo systemctl start firewalld.service # 关闭防火墙 $ sudo systemctl stop firewalld.service # 开机自启 $ sudo systemctl enable firewalld.service # 关闭开机自启 $ sudo systemctl disable firewalld.service 二、firewall-cmd 1、查看状态 $ firewall-cmd --state # running表示运行 2、获取活动的区域 $ firewall-cmd --get-active-zones 3、获取所有支持的服务 $ firewall-cmd --get-service 4、开放某个服务 # 临时，重启后失效 $ firewall-cmd --zone=public --add-service=https # 永久 $ firewall-cmd --permanent --zone=public --add-service=https # 重载防火墙使生效 $ firewall-cmd --reload 5、开放某个端口 # 临时 $ firewall-cmd --zone=public --add-port=8080/tcp # 永久 $ firewall-cmd --permanent --zone=public --add-port=8080/tcp # 重载防火墙使生效 $ firewall-cmd --reload 6、查看开启的服务和端口 # 开启的服务 $ firewall-cmd --permanent --zone=public --list-services # 开启的端口 $ firewall-cmd --permanent --zone=public --list-ports 7、查询服务的启用状态 $ firewall-cmd ---query-service http 8. 查看当前zone中的规则 $ firewall-cmd --list-all public (active) target: default icmp-block-inversion: no interfaces: ens160 sources: services: cockpit dhcpv6-client ssh ports: protocols: forward: no masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: 9. 默认zone管理 $ firewall-cmd --get-default-zone public # 设置默认的zone $ firewall-cmd --set-default-zone=work $ firewall-cmd --set-default-zone=public 删除规则 [root@localhost ~]$ firewall-cmd xxx --remove-service=http ##在home区域内将http服务删除在开放列表中删除 --remove-port=8080 # s --remove-interface=eth0 ##将网络接口在默认的区域内删除 --remove-source=192.168.1.1 ##删除源地址的流量到指定区域 常用的命令如上所示，基本能够满足日常管理和使用。</content></entry><entry><title>CentOS 安装 Python3</title><url>/posts/centos-install-python3/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag><tag>Python</tag></tags><content type="html">CentOS 默认只安装 Python2 ,但未来主流的仍是 Python3，因此有必要在 CentOS 上安装 Python3，以下方式介绍在 CentOS 上编译安装Python3并解决安装后yum无法正常使用的问题。
1、下载Python源代码 wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tgz 2、安装依赖包 yum -y install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 3、解压源码包 tar -xzvf Python-3.6.1.tgz cd Python-3.6.1/ 4、把Python3.6安装到 /usr/local 目录 ./configure --prefix=/usr/local/ make make altinstall 此处使用 make altinstall 安装是为了使Python2 和Python3 能共存，具体可见压缩包里的README文件.
python3.6程序的执行文件：/usr/local/bin/python3.6 python3.6应用程序目录：/usr/local/lib/python3.6 pip3的执行文件：/usr/local/bin/pip3.6 pyenv3的执行文件：/usr/local/bin/pyenv-3.6
5、更改Python链接 当在命令行输入Python时默认打开的是Python2版本，现在把它改为Python3；
cd/usr/bin mv python python.backup ln -s /usr/local/bin/python3.6 /usr/bin/python ln -s /usr/local/bin/python3.6 /usr/bin/python3 rm -rf /usr/bin/python2 ln -s /usr/bin/python2.6 /usr/bin/python2 6、更改yum脚本的Python依赖 现在如果执行yum相关的命令，会发现不能正常执行，因为yum是用Python2开发的，然而此时Python默认指向的是Python3,二者的语法不兼容，所以会出现报错，为了解决此问题，需要修改yum相关命令的python依赖环境
$ cd /usr/bin $ ls yum* yum yum-config-manager yum-debug-restore yum-groups-manager yum-builddep yum-debug-dump yumdownloader 使用vim更改以上文件头为 !/usr/bin/python 改为 #!/usr/bin/python2
这样便能很好的解决Python的版本问题及yum不能正常使用的问题。
附：快捷办法 $ yum install epel-release $ yum makecache $ yum install -y python36</content></entry><entry><title>使用mosquitto设置一个MQTT服务</title><url>/posts/setup-mqtt-server/</url><categories><category>IoT</category></categories><tags><tag>IoT</tag></tags><content type="html">
MQTT 是一种基于 pusblish/subscribe(发布/订阅)的消息通信协议，适用于 M2M (machine to machine)在低带宽条件下进行消息通信。广泛运用于物联网(IoT)领域。本文介绍使用 mosquitto 搭建一个 MQTT Broker。
1、下载安装mosquito $ sudo yum install -y mosquitto 2、修改配置文件 $ sudo vim /etc/mosquitto/mosquitto.conf pid_file /var/run/mosquitto.pid persistence true persistence_location /var/lib/mosquitto/ log_dest file /var/log/mosquitto/mosquitto.log include_dir /etc/mosquitto/conf.d bind_address 172.16.10.80 # 绑定的IP地址 allow_anonymous false # 禁止匿名登录 protocol mqtt password_file /etc/mosquitto/pwfile #密码文件 port 1883 # 监听的端口号 max_connections 100 # 最大连接数 3、设置密码 # 为用户mqtt设置一个密码 $ mosquitto_passwd -c /etc/mosquitto/pwfile mqtt 4、启动服务 $ sudo systemctl start mosquitto.service $ sudo systemctl enable mosquitto.service 5、测试服务 订阅端 $ mosquitto_sub -h 172.16.10.80 -d -u mqtt -P hello -t mqtt/test 发布端 $ mosquitto_pub -h 172.16.10.80 -d -u mqtt -P hello -t mqtt/test -m &amp;#34;Hello!&amp;#34; -h 指定MQTT的IP
-d 打开调试模式
-u 指定用户名
-P 指定密码
-t 指定主题Topic
-m 指定消息内容
一端从 MQTT Broker 订阅一个主题，另一端向 MQTT Broker 发布主题，发布后订阅端便可以收到发布端发布的消息。</content></entry><entry><title>CentOS设置Fail2ban防SSH暴力破解</title><url>/posts/setup-fail2ban/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html">今天查看我的滴滴云服务器的时候，云监控里发现最近两天有两百多次的SSH暴力破解登录，查了下来源IP，都是韩国釜山，安徽什么的。真是防不胜防啊！于是决定研究下SSH的防暴力破解，我选择的程序是Fail2ban。下面介绍如何配置使用。
1、下载安装 Fail2ban安装包在epel源里，如果没安装，需要装上。
$ sudo yum install -y epel-release $ sudo yum install -y fail2ban fail2ban-systemd fail2ban-firewalld 2、修改配置文件 主配置文件/etc/fail2ban/jail.conf不建议修改，自行建一个配置文件,它会覆盖主配置文件的配置项，这样便于管理，升级安装包时也不会被覆盖。
$ sudo vim /etc/fail2ban/jail.d/ssh.local [DEFAULT] # 禁止一个IP24小时 bantime = 24h # 10分钟内尝试登陆3次失败便加入屏蔽列表 findtime = 10m maxretry = 3 # 把自己的IP加入这里，免得自己被ban ignoreip = 127.0.0.1/8 ::1 x.x.x.x [sshd] enabled = true mode = normal port = ssh logpath = %(sshd_log)s backend = %(sshd_backend)s 3、启动Fail2ban服务 $ sudo systemctl start fail2ban.service $ sudo systemctl enable fail2ban.service 4、查看ssh状态 $ fail2ban-client status sshd Status for the jail: sshd |- Filter | |- Currently failed: 0 | |- Total failed: 0 | `- Journal matches: _SYSTEMD_UNIT=sshd.service + _COMM=sshd `- Actions |- Currently banned: 20 |- Total banned: 20 `- Banned IP list: 1.252.24.138 142.93.153.234 157.230.9.239 \ 159.65.145.175 159.65.148.178 159.65.151.151 165.227.39.62 \ 183.157.142.164 183.230.146.26 192.99.255.47 193.201.224.214 \ 195.231.4.214 198.98.56.196 198.98.62.146 206.189.132.42 \ 209.141.35.22 223.113.91.54 24.90.25.51 59.20.205.178 68.183.99.64 5、查看实时日志 $ sudo tail -f /var/log/fail2ban.log 6、最近一个启动fail2ban日志 journalctl -b -u fail2ban 7、查看登录失败的日志 $ sudo cat /var/log/secure |grep &amp;#39;Failed password&amp;#39; May 16 20:42:55 10-255-0-83 sshd[21804]: Failed password for root from 185.244.25.105 port 35412 ssh2 May 16 21:08:06 10-255-0-83 sshd[25255]: Failed password for root from 40.73.39.211 port 41718 ssh2 May 16 21:13:51 10-255-0-83 sshd[25935]: Failed password for root from 105.103.132.251 port 19628 ssh2 8、解锁IP $ fail2ban-client set sshd unbanip IP</content></entry><entry><title>Alpine 基本配置</title><url>/posts/alpine-basic-config/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html">alpine作为一个轻量级docker容器已经是很流行了，alpine linux也是一个很轻量级的linux系统，网上关于docker下配置alpine的例子不少，很少有基于alpine下配置docker环境的，本例即为虚拟机下安装alpine同时配置docker环境
Alpine 操作系统是一个面向安全的轻型 Linux 发行版。目前 Docker 官方已开始推荐使用 Alpine 替代之前的 Ubuntu 做为基础镜像环境。这样会带来多个好处。包括镜像下载速度加快，镜像安全性提高，主机之间的切换更方便，占用更少磁盘空间等。
下载alpine linux镜像 http://mirrors.aliyun.com/ 配置虚拟机 资源分配根据需要可调整，安装过程需要连接外网，dhcp分配IP，开启虚拟机，使用root登录系统，此时不需要密码，直接登录。
安装alpine linux 执行setup-alpine进行安装设置，设置完后重启进入系统
安装后配置 使用root登录，先新进一个用户，alpine linux默认不能使用root远程登录
useradd tem passwd tem 使用tem 用户远程登录后在切换到root su - root
修改镜像源 $ vi /etc/apk/repositories http://mirrors.ustc.edu.cn/alpine/v3.7/main http://mirrors.ustc.edu.cn/alpine/v3.7/community 基本使用 apk update apk add vim git # 搜索package $ apk search vim # 删除package $ apk del vim # 查看package信息 $ apk info vim 安装docker apk add docker rc-update add docker boot #加入开机自启 service docker start docker version #查看版本信息 安装docker-compose apk add py-pip pip install docker-compose 软件包在线查询 https://pkgs.alpinelinux.org/packages</content></entry><entry><title>CentOS7 配置MariaDB数据库</title><url>/posts/centos-config-mariadb/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag><tag>MariaDB</tag></tags><content type="html"><![CDATA[ 自从MySQL数据库被oracle公司收购不在开源后，MySQL的作者就重新开发了一个完全兼容MySQL的数据库软件取名叫MariaDB.在MySQL的基础上加入了一些新的特性，很快得到了开源社区的支持。新版的CentOS7也使用MariaDB替代了MySQL，本文介绍在CentOS7上安装完MySQL后的一些基本配置。
安装MariaDB数据库 $ yum update $ yum install -y mariadb-server 基本概念 mysqld ——服务器程序，守护进程 mysql ——客户端 3306&mdash;&ndash;监听端口 服务器管理工具： 1、mysqlaccess 用于创建账户和设置权限 2、mysqladmin 命令行的数据库管理工具，交互式地查询服务器的状态和使用量，以及关闭服务； 3、mysqlshow 即可显示各数据库和各表的信息，又可查看服务器状态； 4、mysqldump 导出dump文件 修改MariaDB的配置文件 $ sudo vim /etc/my.cnf.d/server.cnf [mysqld] # 让MariaDB支持中文编码 character-set-server=utf8 collation-server=utf8_general_ci $ sudo vim /etc/my.cnf.d/mysql-clients.cnf [mysql] default-character-set=utf8 更改编码为utf-8，加入上面的配置后便可以在数据库表中插入中文的数据。
启动MariaDB数据库服务 sudo systemctl start mariadb.service sudo systemctl enable mariadb.service 初始化数据库 mysql_secure_installation 修改root用户密码 $ mysqladmin -u root -p flush-privileges password “xxxxx” 创建新的用户 使用MariaDB时不建议使用root账户进行操作，建议新建一个用户进行操作，可以保证数据库的安全性。
mysql -u root -p -e &#34;GRANT ALL ON *.* TO &#39;vicent&#39;@&#39;%&#39;;&#34; 上面新建了一个叫vicent的新账户，设置对所有的数据库都有权限，最后的%表示通过vicent这个账户可以从任何地方连接到这个MariaDB服务器。
查看用户信息 mysql -u root -p -e &#34;SELECT User,Host FROM mysql.user;” 删除用户 &gt; drop user 用户名@localhost; 修改用户密码 &gt; set password for vicent@‘%’ = password(‘123’); 远程连接到MariaDB数据库 使用mycli连接数据库，mycli是Python实现的MySQL客户端，支持代码高亮和智能提示，用于如下命令安装mycli
pip3 install mycli 在另一台电脑上连接到MariaDB数据库：
mycli -h 192.168.22.156 -u vicent 学习MariaDB数据库，建议先看看《SQL基础教程》这本书学习SQL语句。本书是一本非常适合初学者入门SQL语句的书。
]]></content></entry><entry><title>Python3爬虫百度翻译查词</title><url>/posts/py-spider-bdfanyi/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html"><![CDATA[百度翻译是一个不错的查词翻译网站，本文介绍使用Python3爬虫实现百度翻译查词的效果，主要的依赖是requests库。
测试环境 Windows10 x64 PyCharm 2018.2 Python3.6.4 依赖 requests 请求的API： https://fanyi.baidu.com/sug 源代码 #!/usr/bin/env python3 # -*- coding:utf-8 -*- # &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; # @File Name: bdfy.py # @Description: 百度翻译 # @Author: pengshp&lt;pengshp3@outlook.com&gt; # @date: 2018/10/14 0014 # &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; import requests def baiduFanyi(word): &#34;&#34;&#34;百度翻译单词查询&#34;&#34;&#34; url = &#39;https://fanyi.baidu.com/sug&#39; header = { &#34;User-Agent&#34;: &#34;Mozilla/5.0&#34; } data = { &#39;kw&#39;: word } response = requests.post(url, headers=header, data=data) resData = response.json() # 把返回的json数据转为字典 result = resData[&#39;data&#39;][0].get(&#39;v&#39;) return result if __name__ == &#39;__main__&#39;: word = input(&#39;请输入你要查询的单词：&#39;) print(baiduFanyi(word)) 主要是使用requests库的post请求方法请求百度翻译的API，把返回的json数据转为字典，再提取数据。
运行测试 ~$ python3 bdfy.py 请输入你要查询的单词：python n. 巨蛇，大蟒; 使用Google Fire封装为CLi #!/usr/bin/env python3 # -*- coding:UTF-8 -*- # @Version: v1.0 # @Author: pengshp&lt;pengshp3@outlook.com&gt; # @License: Apache Licence 2.0 # @Description: 百度翻译API # @File: bdfy.py # @Date: 10月 26,2018 import requests import fire def baiduFanyi(word): &#34;&#34;&#34;百度翻译单词查询&#34;&#34;&#34; url = &#39;https://fanyi.baidu.com/sug&#39; header = { &#34;User-Agent&#34;: &#34;Mozilla/5.0&#34; } data = { &#39;kw&#39;: word } response = requests.post(url, headers=header, data=data) resData = response.json() # 把返回的json数据转为字典 result = resData[&#39;data&#39;][0].get(&#39;v&#39;) return result if __name__ == &#39;__main__&#39;: fire.Fire(baiduFanyi) 使用示例 PS F:\code\myfire&gt; pipenv run python bdfy.py -- --help Type: function String form: &lt;function baiduFanyi at 0x000001A023011E18&gt; File: bdfy.py Line: 15 Docstring: 百度翻译单词查询 Usage: bdfy.py WORD bdfy.py --word WORD PS F:\code\myfire&gt; pipenv run python bdfy.py python n. 巨蛇，大蟒; PS F:\code\myfire&gt; pipenv run python bdfy.py 你好 [nǐ hǎo] hello; hi; How do you do!; 参考 1、 百度翻译 2、 requests中文指南 ]]></content></entry><entry><title>爬取虎扑网步行街帖子信息并写入CSV文件</title><url>/posts/spider-hupubxj-csv/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html"><![CDATA[最近在学Python网络爬虫，自己写了一些小项目，本次介绍使用requests和BeautifulSoup4库爬取虎扑网的帖子信息并写入到CSV文件。
虎扑步行街 的帖子很有意思，记得大学舍友经常看，遇到有意思的会和我们讲，本次爬取步行街帖子的标题，URL，作者，发帖时间，回帖数，浏览数，最后回帖时间，最后回帖人信息并写入到CSV文件。
环境 Python 3.6.4 PyCharm 2018 Windows10 x64 依赖： requests == 2.19.1 beautifulsoup4 == 4.6.3 lxml == 4.2.4 源代码 #!/usr/bin/env python3 # -*- coding:utf-8 -*- # &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; # @Version: v1.0 # @License: Apache Licence 2.0 # @File Name: hupubxj.py # @Description: 爬取虎扑步行街的帖子信息并写入csv文件 # @Author: pengshp &lt;pengshp3@outlook.com&gt; # @Date: 2018/10/19 0019 # &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; import requests from bs4 import BeautifulSoup import bs4 import csv def getHTML(link): &#34;&#34;&#34;获取网站HTML&#34;&#34;&#34; kv = {&#39;User-Agent&#39;: &#39;Mozilla/5.0&#39;} try: r = requests.get(link, headers=kv) r.raise_for_status() html = r.text except requests.HTTPError: print(&#34;爬取异常&#34;) return html def getData(html): &#34;&#34;&#34;获取帖子的详细信息&#34;&#34;&#34; data_list = [] soup = BeautifulSoup(html, &#39;lxml&#39;) ul = soup.find_all(&#39;ul&#39;, class_=&#34;for-list&#34;) for li in ul[0].children: if isinstance(li, bs4.element.Tag): title_box = li.select(&#39;a[class=&#34;truetit&#34;]&#39;) title = title_box[0].string url = &#39;https://bbs.hupu.com%s&#39; % title_box[0][&#39;href&#39;] author = li.select(&#39;a[class=&#34;aulink&#34;]&#39;)[0].string time = li.select(&#39;a[style=&#34;color:#808080;cursor: initial; &#34;]&#39;)[0].string relay_view = li.select(&#39;span[class=&#34;ansour box&#34;]&#39;)[0].string relay = relay_view.split(&#39;/&#39;)[0].strip() view = relay_view.split(&#39;/&#39;)[1].strip() endreply = li.select(&#39;div[class=&#34;endreply box&#34;]&#39;)[0].a.string endauthor = li.select(&#39;div[class=&#34;endreply box&#34;]&#39;)[0].span.string data_list.append([title, url, author, time, relay, view, endreply, endauthor]) return data_list if __name__ == &#39;__main__&#39;: link = &#39;https://bbs.hupu.com/bxj&#39; page = getHTML(link) datas = getData(page) for data in datas: with open(&#39;bxj.csv&#39;, &#39;a+&#39;, encoding=&#39;utf-8&#39;, newline=&#39;&#39;) as f: w = csv.writer(f) w.writerow(data) print(&#34;数据写入完成！&#34;) 思路： 先使用requests库获取网页的HTML，再使用bs4库解析网页中的数据，这里是难点，需要对照源码找到对应的标签，并提取所需的信息,把单个帖子所有的信息存为一个List，再把每个List加入到总的数据List中，相当于一个二维数组。写数据时一个帖子的所有信息作为一行写入bxj.csv.
结果 打开bxj.csv查看数据。 ]]></content></entry><entry><title>树莓派Archlinux Arm 基本配置教程</title><url>/posts/archlinux-arm-config/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag><tag>RaspberryPi</tag></tags><content type="html"><![CDATA[本文主要介绍在树莓派上配置Ａrchlinux系统，因为Ａrchlinux是精简安装，所以安装完后要做一些基本的配置和优化。可根据自己的需要进行配置，这里是我的配置记录，可供参考。
一.基本配置 配置网络 有线网络 # 有线网络 ~$ sudo vim /etc/systemd/network/20-wired.network [Match] Name=eth0 # w Type=ether [Network] DHCP=yes ## 静态IP [Network] Address=10.1.10.9/24 Gateway=10.1.10.1 DNS=10.1.10.1 #DNS=8.8.8.8 # 启动网络服务 ~$ sudo systemctl enable --now systemd-networkd.service 无线网络wlan # 安装包 $ pacman -S wireless_tools dialog libnl wpa_supplicant # SSID PASSWD ~$ wpa_passphrase HUAWEI 12345678 network={ ssid=&#34;HUAWEI&#34; #psk=&#34;12345678&#34; psk=3a0da8cfedc18f6d7d8c61427378d2a9b1348b3541055535cc } ~$ sudo vim /etc/wpa_supplicant/wpa_supplicant-wlan0.conf ctrl_interface=/var/run/wpa_supplicant ctrl_interface_group=wheel update_config=1 fast_reauth=1 ap_scan=1 network={ ssid=&#34;HUAWEI&#34; #psk=&#34;12345678&#34; psk=3a0da8cfedc18f6d7d8c61427378d2a9b1348b3541055535cc } ~$ sudo systemctl enable --now wpa_supplicant@wlan0.service ~$ sudo vim /etc/systemd/network/25-wireless.network [Match] Name=wlan0 # 网卡名 Type=wlan [Network] DHCP=yes ~$ sudo systemctl enable --now systemd-networkd.service 1.更新系统 sudo pacman -Syu 2.更新时区 timedatectl set-timezone Asia/ShangHai 3.把用户加入用户组 pacman -S sudo nano /etc/sudoers 添加
# 执行sudo 时不需要输入密码 %wheel ALL=(ALL) NOPASSWD: ALL ４.安装中文字体 # 安装思源黑体字体 ~$ sudo pacman -S adobe-source-han-sans-cn-fonts ５.基本开发环境 ~$ sudo pacman -Sy git vim ~$ sudo pacman -Sy tldr ~$ sudo pacman -Sy bat tree ６.安装Python3 sudo pacman -S python python-pip ipython ７.系统监测 sudo pacman -S htop neofetch 二.安装桌面环境 1.安装基本组建 sudo pacman -S base-devel 2.安装桌面服务 sudo pacman -S xorg-xinit xorg-server xorg-utils xorg-server-utils 3.安装音视频相关驱动 sudo pacman -S xf86-video-fbdev xf86-video-vesa 4.安装mate桌面环境 sudo pacman -S mate mate-extra 5.安装管理器，启动器 pacman -S openbox lxde gamin dbus mesa 6.修改配置文件 添加如下内容
$ sudo vim ~/.xinitrc exec mate-session 7.关机重启 开机启动后登陆输入startx便可以进入mate桌面环境。到此桌面环境配置完成了。
三.进阶配置 1.安装fcitx输入法 sudo pacman -S fcitx fcitx-sunpinyin fcitx-configtool 编辑~/.xinitrc
$ vim ~/.xinitrc export LANG=zh_CN.UTF-8 export XIM=fcitx export XMODIFIERS=&#34;@im=fcitx&#34; export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XIM_PROGRAM=fcitx fcitx &amp; 保存退出！
2.安装火狐浏览器 $ sudo pacman -S firefox firefox-i18n-zh-cn 3.设置中文环境 $ sudo vim /etc/locale.conf LANG=zh_CN.UTF-8 # or ~$ localectl set-locale LANG=en_US.UTF-8 ~$ localectl status 4.音频设置 $ pacman -Sy alsa-utils alsa-firmware alsa-lib alsa-plugins 选择一个音频输出 amixer cset numid=3 x
参数设置为：
0 自动 1 模拟输出 3 HDMI 5.安装zsh ~$ sudo pacman -Sy zsh ~$ sudo pacman -Sy community/zsh-completions ~$ sudo pacman -Sy community/zsh-autosuggestions ~$ sudo pacman -Sy community/zsh-syntax-highlighting ~$ sudo pacman -Sy community/zsh-theme-powerlevel10k # 设置alarm的默认shell为zsh $ chsh -s /bin/zsh alarm 6. 使用yay管理 AUR yay简介 Jguer/yay: Yet another Yogurt - An AUR Helper written in Go (github.com) yay使用go语言写的yogurt的替代品，用来管理AUR包,使用时不需要加sudo
# install yay pacman -S --needed git base-devel git clone https://aur.archlinux.org/yay-bin.git cd yay-bin makepkg -si 修改源 修改的配置文件位于 ~/.config/yay/config.json
~$ yay --aururl &#34;https://aur.tuna.tsinghua.edu.cn&#34; --save # c ~$ yay -P -g 基本使用 $ yay -Sy [pkg] # 打印系统包信息 $ yay -Ps # 清除未使用的依赖 $ yay -Yc # install Google Noto font ~$ yay -Sy noto-fonts-sc # install OSX fonts ~$ yay -Sy ttf-mac-fonts 7. 安装中文man_page ~$ sudo pacman -Sy community/man-pages-zh_cn ]]></content></entry><entry><title>LEDE/OpenWrt路由器使用Adblock屏蔽小米广告</title><url>/posts/lede-adblock-admi/</url><categories><category>OpenWrt</category></categories><tags><tag>OpenWrt</tag></tags><content type="html"><![CDATA[小米的生态链产品做的不错，但无奈小米手机上的广告太多，实在无法忍受，有网友推出了小米净化APP用于屏蔽小米的广告，本文介绍如何在LEDE/OpenWrt路由器使用Adblock插件屏蔽小米烦人的广告。
准备 刷了LEDE/OpenWrt的路由器 小米手机 网络 1、远程登录到路由器后台 ssh root@192.168.31.1 #改为自己的IP BusyBox v1.25.1 () built-in shell (ash) _________ / /\ _ ___ ___ ___ / LE / \ | | | __| \| __| / DE / \ | |__| _|| |) | _| /________/ LE \ |____|___|___/|___| lede-project.org \ \ DE / \ LE \ / ---------------------------------------------- \ DE \ / Reboot (17.01.4, r3560-79f57e422d) \________\/ ---------------------------------------------- root@HiWiFi:~# 2、安装中文支持包 root@HiWiFi:~# opkg update root@HiWiFi:~# opkg install luci-i18n-base-zh-cn 3、安装Adblock插件 root@HiWiFi:~# opkg install adblock luci-app-adblock root@HiWiFi:~# opkg install luci-i18n-adblock-zh-cn 4、设置 在WebUI管理界面设置Adblock的黑名单，加入如下的域名 依次点击：服务&mdash;&gt;Adblock&mdash;&gt;高级&mdash;&gt;编辑黑名单
a.stat.xiaomi.com a.union.mi.com abtest.mistat.xiaomi.com adinfo.ra1.xlmc.sec.miui.com adv.sec.miui.com api.ad.xiaomi.com api.ra2.xlmc.sec.miui.com api.tuisong.baidu.com api.tw06.xlmc.sec.miui.com app01.nodes.gslb.mi-idc.com app02.nodes.gslb.mi-idc.com app03.nodes.gslb.mi-idc.com applog.uc.cn beha.ksmobile.com bss.pandora.xiaomi.com calopenupdate.comm.miui.com cdn.ad.xiaomi.com cm.p4p.cn.yahoo.com cm066.getui.igexin.com connect.rom.miui.com data.mistat.xiaomi.com e.ad.xiaomi.com etl.xlmc.sandai.net fcanr.tracking.miui.com fclick.baidu.com get.sogou.com hm.xiaomi.com hub5pn.wap.sandai.net idx.m.hub.sandai.net image.box.xiaomi.com info.analysis.kp.sec.miui.com info.sec.miui.com logupdate.avlyun.sec.miui.com m.bss.pandora.xiaomi.com m.irs01.com m.sjzhushou.com master.wap.dphub.sandai.net mdap.alipaylog.com migc.g.mi.com migcreport.g.mi.com migrate.driveapi.micloud.xiaomi.net mis.g.mi.com mlog.search.xiaomi.net new.api.ad.xiaomi.com notice.game.xiaomi.com nsclick.baidu.com o2o.api.xiaomi.com p.alimama.com pdc.micloud.xiaomi.net ppurifier.game.xiaomi.com pre.api.tw06.xlmc.sandai.net r.browser.miui.com reader.browser.miui.com report.adview.cn resolver.gslb.mi-idc.com resolver.msg.xiaomi.net sa.tuisong.baidu.com sa3.tuisong.baidu.com sdk.open.phone.igexin.com sdk.open.talk.gepush.com sdk.open.talk.igexin.com sdkconfig.ad.xiaomi.com sec-cdn.static.xiaomi.net sec.resource.xiaomi.net security.browser.miui.com sg.a.stat.mi.com staging.admin.e.mi.com test.ad.xiaomi.com test.api.xlmc.sandai.net test.e.ad.xiaomi.com test.new.api.ad.xiaomi.com tracking.miui.com tw13b093.sandai.net union.dbba.cn update.avlyun.sec.miui.com www.adview.cn yun.rili.cn zhwnlapi.etouch.cn api.comm.miui.com 备注：以上域名引自小米净化APP
5、注意事项 Adblock的配置的Download Utility最好选择uclient-fetch,并且安装SSL库
root@HiWiFi:~# opkg install libustream-openssl 拦截来源列表里推荐勾选上reg_cn，对国内的广告拦截效果较好。
6、重启小米路由器 root@HiWiFi:~# reboot 此时再打开小米的APP，如：小米路由器就发现启动时的广告没了，清爽的感觉又回来了！
]]></content></entry><entry><title>Linux 的时间同步那些事</title><url>/posts/centos-ntpdate/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag></tags><content type="html">Linux中很多服务需要进行时间同步，不然容易导致出错。本文介绍使用阿里云的时间服务器同步服务器的时间。下面介绍三种时间同步的方案。
方案1：使用NTP同步时间 1、安装软件 $ yum install -y ntpdate 2、时间同步服务器 可用的时间同步服务器，阿里提供了一些NTP时间服务器可以用于从互联网中同步服务器的时间；ntp.aliyun.com
ntp1.aliyun.com ntp2.aliyun.com ntp3.aliyun.com ntp4.aliyun.com 3、同步时间 从上面的时间同步服务器中选择一个进行时间同步。
$ ntpdate -u ntp.aliyun.com 4、加入计划任务 可以把时间同步加入系统的计划任务，定时从互联网同步时间
$ crontab -e * */2 * * * ntpdate -u ntp1.aliyun.com &amp;amp;&amp;gt; /dev/null # 每两个小时同步一次时间 $ systemctl start crond $ systemctl enable crond 复杂，不便利，暂时不推荐使用。
方案2：使用chrony同步时间 1. 修改配置文件 [xdl@CentOS] ~$ sudo vim /etc/chrony.conf pool ntp1.aliyun.com iburst 2. 启动服务 [xdl@CentOS] ~$ sudo systemctl enable --now chronyd.service 3. 查看状态 [xdl@CentOS] ~$ chronyc sources -v 210 Number of sources = 1 MS Name/IP address Stratum Poll Reach LastRx Last sample =============================================================================== ^* 120.25.115.20 2 6 37 64 -285us[-4209us] +/- 12ms 暂时推荐使用 chrony进行时间同步。
方案3：使用systemd管理时间同步 systemd的组件中有一个timesyncd的服务专门用来管理时间同步。
安装软件 $ dnf install -y systemd-timesyncd 修改配置文件 $ sudo vim /etc/systemd/timesyncd.conf # See timesyncd.conf(5) for details. [Time] NTP=ntp.aliyun.com 启动服务 $ sudo systemctl stop chronyd.service $ sudo systemctl enable --now systemd-timesyncd.service $ sudo systemctl status systemd-timesyncd.service 验证时间同步状态 $ timedatectl status Local time: 六 2021-12-25 17:36:02 CST Universal time: 六 2021-12-25 09:36:02 UTC RTC time: 六 2021-12-25 09:36:02 Time zone: Asia/Shanghai (CST, +0800) System clock synchronized: yes # &amp;lt;----- 时间同步开启 NTP service: inactive RTC in local TZ: no 总结： 随着systemd的普及，更推荐使用方案3，简单，和系统结合性更好，而且占用的内存更小。</content></entry><entry><title>CentOS搭建FTP服务器</title><url>/posts/centos-install-ftp-server/</url><categories><category>CentOS</category></categories><tags><tag>Linux</tag><tag>CentOS</tag></tags><content type="html"><![CDATA[ FTP是文件传输协议，可实现Windows和Linux之间快速的上传和下载文件。CentOS下搭建FTP服务器一般使用vsftpd,搭建的环境为CentOS7.4,下面是搭建和配置过程。
安装FTP服务 $ sudo yum -y install vsftpd 配置FTP服务器 了解vsftpd配置 vsftpd的配置目录为/etc/vsftpd,主要包括下面的配置文件：
vsftpd.conf 主配置文件 ftpusers 配置禁止访问FTP服务器的用户列表 user_list 配置用户访问控制 FTP服务器的身份验证模式：
匿名开放&mdash;无需密码验证可登陆FTP服务器，最不安全 本地用户&mdash;通过Linux本地的账号密码进行验证，存在暴力破解的风险，相对安全； 虚拟用户&mdash;FTP传输服务单独建立数据库文件，虚拟出来口令验证的账户信息，但账号是在服务器系统不存在，仅供FTP传输服务验证使用，最安全； 为了保证安全性，本文配置的FTP服务器为匿名访问模式； 阻止匿名访问和切换根目录 匿名访问和切换根目录都会给服务器带来安全风险，建议关闭这两个功能。编辑主配置文件
$ sudo vim /etc/vsftpd/vsftpd.conf # 禁止匿名用户 anonymous_enble=NO # 禁止切换根目录 chroot_local_user=YES # 开启虚拟用户模式 guest_enable=YES listen=YES listen_port=21 download_enable=YES 编辑完后:wq保存退出。
创建FTP用户 创建一个新的用户ftpuser
$ sudo useradd ftpuser 为用户ftpuser设置密码，xxx改为自己的密码
$ echo &quot;xxxxx&quot; |passwd ftpuser --stdin 限制FTP用户只能FTP访问 为了安全，限制用户ftpuser只能通过FTP访问服务器，而不能直接登录服务器。
$ usermod -s /sbin/nologin ftpuser 为用户分配主目录 FTP服务器默认的访问目录为/var/ftp
启动FTP服务器并开机自启 $ sudo systemctl start vsftpd $ sudo systemctl enble vsftpd 设置防火墙允许FTP访问 设置防火墙永久允许FTP访问
$ firewall-cmd --add-service=ftp --permanent $ firewall-cmd --reload # 重载防火墙 访问FTP服务器 方案一： Windows的资源管理器地址栏里输入 ftp://ftpuser:xxxxx@192.168.22.156 方案二： 通过FTP客户端工具访问 使用开源免费并且跨平台的FileZilla客户端访问，填入FTP服务器的IP地址，用户名和密码便可以访问。
]]></content></entry><entry><title>更新CentOS7.4到CentOS7.5</title><url>/posts/centos7-upgrade/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag></tags><content type="html">2018年5月15日，CentOS官方发布了最新的CentOS7.5（1804）系统，加入了一些新的特性，下面介绍如何更新系统到最新的CentOS7.5。
更新方法 1、查看当前的系统版本 $ cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) 2、更新系统 $ sudo yum clean all $ sudo yum upgrade $ sudo systemctl reboot 3、查看新的系统版本 $ cat /etc/redhat-release CentOS Linux release 7.5.1804 (Core) 参考链接 1、 官方博客 2、 下载地址</content></entry><entry><title>树莓派配置 dnscrypt-proxy</title><url>/posts/rpi-dnscrypt-proxy/</url><categories><category>RaspberryPi</category></categories><tags><tag>RaspberryPi</tag></tags><content type="html"><![CDATA[ dnscrypt-proxy可防止DNS污染，最新的2.0.x版本增加缓存DNS功能，加快DNS解析速度。
下载 $ wget https://github.com/jedisct1/dnscrypt-proxy/releases/download/2.0.44/dnscrypt-proxy-linux_arm-2.0.44.tar.gz 解压 $ tar -zxf dnscrypt-proxy-linux_arm-2.0.44.tar.gz -C /usr/local/ $ cd /usr/local/ $ mv linux-arm dnscrypt 修改配置文件 $ mv example-dnscrypt-proxy.toml dnscrypt-proxy.toml $ vim dnscrypt-proxy.toml server_names = [&#39;rubyfish-ea&#39;, &#39;alidns-doh&#39;, &#39;cloudflare&#39;] listen_addresses = [&#39;127.0.0.1:53&#39;, &#39;[172.16.10.10]:53&#39;] log_file = &#39;dnscrypt-proxy.log&#39; fallback_resolver = &#39;208.67.222.222:53&#39; cache = true cache_size = 15000 ... 把上面的172.16.10.10改为树莓派局域网内的IP地址。server_names会自动选择一个最快的使用，我的测试了alidns-doh[阿里服务器]延迟较低。极客DNS和红鱼DNS是中国大陆的服务器，其它一些高级的功能可根据自己的需要更改。
eg.
自定义域名解析 域名黑名单 过滤广告 安装服务 $ sudo /usr/local/dnscrypt/dnscrypt-proxy -service install 启动服务 $ sudo dnscrypt-proxy -service start # 使用systemctl管理服务 $ sudo systemctl start dnscrypt-proxy.service 基本使用 $ sudo dnscrypt-proxy -service stop $ sudo dnscrypt-proxy -service restart $ sudo dnscrypt-proxy -service uninstall 使用方法 网络配置里修改DNS配置为树莓派的IP地址。便可以使用本地的DNS解析。
参考 dnscrypt wiki dnscrypt-proxy ]]></content></entry><entry><title>Ubuntu 编译OpenWrt与SDK</title><url>/posts/build-openwrt-sdk/</url><categories><category>OpenWrt</category></categories><tags><tag>OpenWrt</tag><tag>sdk</tag></tags><content type="html"><![CDATA[本文介绍如何使用ubuntu编译OpenWrt的SDK。
一.开发准备 1.Ubuntu18.04 64bit 2.VMware 3.ar71xx架构路由器 二.开发环境搭建 1.安装依赖环境
sudo apt-get update sudo apt-get install build-essential subversion git-core libncurses5-dev \ zlib1g-dev gawk flex quilt libssl-dev xsltproc \ libxml-parser-perl mercurial bzr ecj cvs unzip 2.下载OpenWrt源代码
# Lean&#39;s OpenWrt git clone https://github.com/coolsnowwolf/lede 3.下载并安装所有可用的&quot;feeds&quot;
cd lede ./scripts/feeds update -a ./scripts/feeds install -a 4.运行下面的命令让OpenWrt编译系统检查你的编译环境中缺失的软件包:
make defconfig make prereq 三.开始编译 1.配置编译选项
make menuconfig 出现下图面的界面，选择需要的安装配置信息 Y：选择Y，该软件将被编译，并且加入到你的目标固件里； M：选择M，该软件包将会被编译，但不会被放入固件里。在需要它的时候，可以用OPKG软件包管理器进行安装； N：选择N，该软件包将不会被编译，也不会被安装进固件。 方向键是移动光标 回车键是确认 空格键是选择，可以代替Y/M/N键的使用 /:搜索
备注：记得勾选Build the OpenWrt SDK
经过多次失败的尝试，发现从官网下的OpenWrt SDK不能使用，总是编译出错，自己编译的确能够正常的使用，可能是使用的开发环境以及编译的版本不同吧
2.配置代理
export http_proxy=&#39;socks5://172.16.10.10:1080&#39; export https_proxy=&#39;socks5://172.16.10.10:1080&#39; 3.开始编译
make download make -j2 V=s 等待一段时间，便/bin/$target找到刷机的固件和SDK.
4.后期处理,清空多余的中间文件
make dirclean make clean make distclean 接下来将介绍使用OpenWrt SDK编译自己的软件包。
更多进阶的配置参考： http://www.jianshu.com/p/66c7b0969a31 ]]></content></entry><entry><title>HAProxy实现负载均衡</title><url>/posts/haproxy-load-balancing/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag></tags><content type="html"><![CDATA[当随着访问量的增加时，原来的单台服务器难以承受大量的访问时，就需要使用负载均衡来分担服务器的压力。本文介绍使用HAProxy实现一个免费、高效、可靠的高可用负载均衡解决方案。
HAProxy简介 HAProxy是免费、高效、可靠的高可用负载均衡解决方案。适合处理高负载站点的七层数据请求，对外可屏蔽内部的真实Web服务器，防止内部服务器遭受外部攻击。
HAProxy解决方案 客户端IP：将客户端IP进行Hash计算并保存，当相同的IP访问代理服务器时可以转发至相同的后端服务器； Cookie：依靠真实服务器发送给客户端的Cookie信息进行会话保持； Session：保存真实服务器的Session及服务标识，实现会话保持功能； 实验拓扑图 实验配置 HAProxy配置 1、安装HAProxy
$ yum install -y haproxy 2、修改配置文件
$ [root@CentOS7] ~$ vim /etc/haproxy/haproxy.cfg global log 127.0.0.1 local2 chroot /var/lib/haproxy pidfile /var/run/haproxy.pid maxconn 4000 user haproxy group haproxy daemon # turn on stats unix socket stats socket /var/lib/haproxy/stats frontend haproxy_inbound bind *:80 default_backend haproxy_httpd backend haproxy_httpd balance roundrobin option httpchk GET /index.html # 健康检查 server web1 192.168.10.129:80 check server web2 192.168.10.130:80 check 3、内核优化
$ vim /etc/security/limits.conf * soft nofile 65535 * hard nofile 65535 4、开启日志服务
# 修改日志配置文件 $ vim /etc/rsyslog.conf $ModLoad imudp $UDPServerRun 514 local3.* /var/log/haproxy.log # 重启日志服务 $ systemctl restart syslog 5、开启HAProxy
$ haproxy -f /etc/haproxy/haproxy.cfg 后端Web服务器配置 后端服务器配置基本相同，为了验证试验效果，后端网页不同 1、配置网卡
$ vim /etc/sysconfig/network-scripts/ifcfg-ens33554984 NAME=ens33554984 BOOTPROTO=&#39;static&#39; ONBOOT=&#34;yes&#34; IPADDR=192.168.10.129 GATEWAY=192.168.10.128 #网关指向HAProxy的内网IP TYPE=&#34;Ethernet&#34; $ systemctl restart network 2、Apache配置 网页文件做修改，其他配置相同
[root@CentOS7] ~$ yum install -y httpd # Web-1 [root@CentOS7] ~$ echo &#34;This is Web-1&#34; &gt; /var/www/html/index.html # Web-2 [root@CentOS7] ~$ echo &#34;This is Web-2&#34; &gt; /var/www/html/index.html [root@CentOS7] ~$ systemctl start httpd [root@CentOS7] ~$ systemctl enable httpd 测试 重启HAProxy
$ systemctl restart haproxy.service 浏览器打开 http://192.168.10.128 ,刷新网页，便可以看到在Web-1和Web-2之间轮询。实现一个负载均衡。
]]></content></entry><entry><title>Web 缓存代理服务器polipo</title><url>/posts/web-cache-proxy-polipo/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html"><![CDATA[Polipo 是一个小而快速的缓存web 代理程序(web 缓存, HTTP 代理, 代理服务器)。可以实现HTTP和SOCKS代理。为了最小化延迟，Polipo管线化多个资源请求，在同一个TCP/IP连接上多路复用。Polipo具有HTTP 1.1兼容，支持IPv4、IPv6，流量过滤和隐私增强。
测试环境：CentOS7
下载编译安装 # 下载源码 $ wget https://github.com/jech/polipo/archive/polipo-1.1.1.tar.gz # 解压 $ tar -zxf polipo-1.1.1.tar.gz # 安装依赖 $ yum install texinfo gcc make # 编译 $ cd polipo-polipo-1.1.1/ $ make all # 安装 $ su -c &#39;make install&#39; 创建相关的配置文件 # 创建日志文件 $ mkdir /var/log/polipo $ touch /var/log/polipo/polipo.log # 创建配置目录 $ mkdir /etc/polipo 新建服务启动文件 $ vim /usr/lib/systemd/system/polipo.service [Unit] Description=polipo web proxy After=network.target [Service] Type=simple WorkingDirectory=/tmp User=root Group=root ExecStart=/usr/local/bin/polipo -c /etc/polipo/config Restart=always SyslogIdentifier=Polipo [Install] WantedBy=multi-user.target 创建服务配置文件 $ vim /etc/polipo/config logSyslog = true socksParentProxy = &#34;localhost:1080&#34; #上层Socks5代理 socksProxyType = socks5 logFile = /var/log/polipo/polipo.log logLevel = 4 proxyAddress = &#34;0.0.0.0&#34; #监听IP proxyPort = 8123 allowedClients = 192.168.10.0/24 #允许连接的客户端 chunkHighMark = 50331648 #使用的较多的内存 objectHighMark = 16384 diskCacheRoot = &#34;/var/cache/polipo&#34; #缓存文件存储目录 cacheIsShared = true #分享缓存 serverMaxSlots = 64 serverSlots = 16 serverSlots1 = 32 dnsQueryIPv6 = no #不适用IPv6，加快DNS查询速度 dnsUseGethostbyname = yes #使用系统的resolver 启动代理服务 $ systemctl start polipo.service $ systemctl enable polipo.service 基本使用 把浏览器的代理配置为polipo服务器的IP地址，端口为8123，便可以使用polipo代理上网，加快网页的访问速度。
说明： 如果实在树莓派上使用，可直接使用apt安装，并复制配置文件直接修改配置,可直接使用systemctl管理服务。
$ cp /usr/share/doc/polipo/examples/config.sample /etc/polipo/config ]]></content></entry><entry><title>内网穿透服务Frp</title><url>/posts/intranet-penetration-frp/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html">frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。当想从公网环境访问家里或公司局域网内的服务器时便可以使用frp搭建内网穿透服务实现此功能。
1、原理介绍 Frp是C/S架构，在具有公网IP的服务器上搭建Frp的服务端，在本地局域网搭建Frp客户端；Frp通过将局域网内的IP端口映射到公网IP的某个端口上，当我们访问公网IP的这个端口时，相当于访问了其映射的局域网内的 IP:Port
2、服务条件 具有公网IP的服务器 客户端和服务端使用相同或相近的版本 3、服务端搭建 下载对应系统的最新的程序 frp 解压缩，进入解压目录 修改配置文件
$ vim frps.ini [common] bind_port = 7000 bind_udp_port = 7001 kcp_bind_port = 7000 dashboard_port = 7500 # dashboard 用户名密码，默认都为 admin dashboard_user = admin dashboard_pwd = admin vhost_http_port = 80 token = xxxx #自定义 max_pool_count = 5 max_ports_per_client = 0 authentication_timeout = 900 subdomain_host = xxxxx.com tcp_mux = true 启动Frp服务端
$ nohup ./frps -c ./frps.ini &amp;amp; 4、客户端搭建 下载相同的程序 修改配置文件
$ vim frpc.ini [common] server_addr = x.x.x.x #公网IP地址 server_port = 7000 log_file = /usr/local/frp/frpc.log # trace, debug, info, warn, error log_level = info log_max_days = 3 token = xxxxxx #修改 pool_count = 5 tcp_mux = true user = pi login_fail_exit = true protocol = tcp [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 remote_port = 6000 [gogs] type = http local_ip = 172.16.10.80 local_port = 3000 use_encryption = true use_compression = false subdomain = gogs #custom_domains = gogs.xxxx.com 启动本地客户端
$ nohup ./frpc -c ./frpc.ini &amp;amp; ssh连接局域网内的服务器
$ ssh -oPort=6000 root@x.x.x.x 也可在局域网搭建能够被公网访问的Web服务器，开启80或443端口，更多高级的配置请参考下面的文档。
5.systemctl管理frpc服务 $ vim /lib/systemd/system/frpc.service [Unit] Description=frpc daemon After=network.target syslog.target Wants=network.target [Service] Type=simple Restart=always ExecStart=/usr/local/frp/frpc -c /usr/local/frp/frpc.ini [Install] WantedBy=multi-user.target 服务端同理，把frpc改为frps
5、参考文档 1、 Frp说明文档</content></entry><entry><title>Pipenv 使用指南</title><url>/posts/pipenv-guide/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html">pipenv是requests作者的一个项目, 整合了virtualenv, pip的优点，用于更方便地为项目建立虚拟环境并管理虚拟环境中的第三方模块。后来这个项目交给Python基金会维护。
为什么要使用Pipenv？：
自动关联项目相关的 virtualenv，能够快速的加载 virtualenv。 提供的 pipenv替代 pip并自带一个依赖清单 Pipfile，和依赖锁定 Pipfile.lock。 其中 Pipfile除了依赖清单还支持固定 pypi源地址,固定 python版本。 Pipfile还支持 dev依赖清单. pipenv install的包会强制使用 Pipfile中的源. 解决了 pip install pandas时里的 numpy依旧走官方 pypi. 还有就是可以直接切换 python2,3 使用 pipenv graph命令可以看到依赖树 1、安装Pipenv pip3 install pipenv 2、创建虚拟环境 pipenv管理虚拟环境是按项目来的, 要为你的某个项目新建一个虚拟环境, 只需要在项目目录下运行如下命令:
# 新建Python2 的虚拟环境 pipenv --two # 新建Python3 的虚拟环境 pipenv --three # 更换豆瓣的pipy源 sed -i s/pypi.python.org/pypi.doubanio.com/g Pipfile 该命令会在项目目录下生成一个Pipfile的文件，用于记录虚拟环境的信息及第三方依赖的信息。
3、安装第三方模块 pipenv可以自动安装你项目的第三方模块 :
pipenv install 安装列表是通过读取pipfile, pipfile.lock文件实现的, 如果没有这两个文件就根据requirements.txt生成pipfile和pipfile.lock并读取. 如果想单独安装某个模块还可以指定模块名安装:
pipenv install sanic 单独安装模块后会自动将新模块信息添加到pipfile中, 要同时更新pipfile.lock需要运行:
pipenv lock 4、进入虚拟环境 # 进入虚拟环境 pipenv shell # 退出 exit 还有一个 pipenv run的可以直接执行 virtualenv环境下的命令。
5、基本命令 Usage: pipenv [OPTIONS] COMMAND [ARGS]... Options: --update 升级 pipenv, pip 到最新. --where 输出项目的目录信息. --venv 输出 virtualenv 的目录信息. --py 输出 Python 解析器的路径. --envs 输出环境变量的设置. --rm 删除当前 virtualenv. --bare Minimal output. --completion Output completion (to be evald). --man 显示使用手册. --three / --two 使用 Python 3/2 来创建 virtualenv --python TEXT 直接指定 Python 解析器. --site-packages 拷贝系统 site-packages 到 virtualenv. --jumbotron An easter egg, effectively. --version 显示版本信息并退出. -h, --help 显示当前信息并退出. Commands: check 检查安全漏洞和反对 PEP 508 标记在Pipfile提供. graph 显示当前依赖关系图信息. install 安装提供的包，并加入 Pipfile 的依赖清单中 lock 生成 Pipfile.lock. open 在编辑器(vim)查看一个特定模块. run 在 virtualenv 中执行命令. shell 切换到 virtualenv 中. uninstall 删除提供的包，并清理 Pipfile 的依赖清单中. update 卸载当前所以依赖，然后安装最新包</content></entry><entry><title>CentOS7基本配置</title><url>/posts/centos-basic-config/</url><categories><category>CentOS</category></categories><tags><tag>CentOS</tag><tag>Linux</tag></tags><content type="html"><![CDATA[ CentOS是目前主流的服务器发行版本，本文介绍CentOS初始化安装后的一些基本配置，版本为最新的CentOS7.4.安装时勾选安装基本的开发组件。
1、配置网络 sudo nmtui # 配置IP sudo systemctl start network sudo systemctl enable network 2、修改yum源 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo yum clean all yum makecache 3、更新软件源 $ yum -y update $ yum -upgrade 4、安装pip yum -y install epel-release yum -y install python3-pip sudo pip3 install --upgrade pip 5、安装 zsh + oh my zsh $ yum install zsh git $ git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh $ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc $ vim ~/.zshrc export PATH=$HOME/bin:/usr/local/bin:$PATH ZSH_THEME=&#34;sammy&#34; export ZSH=$HOME/.oh-my-zsh plugins=( zsh-syntax-highlighting zsh-autosuggestions git ) export MANPATH=&#34;/usr/local/man:$MANPATH&#34; export ARCHFLAGS=&#34;-arch x86_64&#34; $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting $ git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions $ chsh -s /bin/zsh 6、安装vim $ yum -y install vim 配置vim [root@CentOS7] ~$ vim /etc/vim/vimrc &#34; 开启语法高亮 syntax on &#34; 检测文件类型 filetype on &#34; 设置在Vim中可以使用鼠标，防止终端无法拷贝 if has(&#39;mouse&#39;) set mouse-=a endif &#34; 显示当前行号和列号 set ruler &#34; 在状态栏显示正在输入的命令 set showcmd &#34; 左下角显示当前Vim模式 set showmode &#34; 显示行号 &#34;set number &#34; 设置tab宽度 set tabstop=4 &#34; 智能自动缩进 set smartindent &#34; 设置自动对齐空格数 set shiftwidth=4 &#34; 设置编码方式 set encoding=utf-8 set helplang=cn set shiftwidth=4 set softtabstop=4 set magic set cursorline set hlsearch set incsearch &#34; set autoindent &#34; 使用空格代替tab set expandtab set smarttab 7、安装常用软件 $ yum install -y net-tools git htop lrzsz 8、安装中文支持包 $ yum -y groupinstall chinese-support 9、安装基本编译环境 $ yum -y install gcc gcc-c++ make 10、关闭SELinux $ vim /etc/selinux/config SELINUX=disabled 11、设置主机名 $ hostnamectl set-hostname CentOS7 12、设置时区 $ timedatectl set-timezone Asia/Shanghai 13. 安装vm-tools ~$ yum install -y open-vm-tools ~$ sudo systemctl enable --now vmtoolsd.service ]]></content></entry><entry><title>Python 的 IP 地址处理模块 IPy</title><url>/posts/python3-ipy/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html"><![CDATA[IP 地址规划是网络设计中很重要的一个环节，在此过程中，免不了要计算大量的IP 地址，包括网段、子网掩码、广播地址、子网数、IP类型等。Python 提供了一个强大的第三方模块IPy,可以辅助我们高效的完成 IP 的规划工作。
1、安装 IPy 模块 pip3 install ipy 2、IP 地址、网段的基本数理 IPy 模块包含一个IP类,可以方便的处理绝大部分格式为 IPv4 和 IPv6 格式的网络和地址。
&gt;&gt;&gt; from IPy import IP &gt;&gt;&gt; IP(&#39;10.0.0.0/8&#39;).version() 4 &gt;&gt;&gt; IP(&#39;::1&#39;).version() 6 通过指定的网段输出该网段的IP个数及所有的IP地址清单
#!/usr/bin/env python3 from IPy import IP ip=IP(&#39;192.168.22.0/24&#39;) print(ip.len()) for x in ip: print(x) 反向地址解析,IP类型，IP转换
&gt;&gt;&gt; from IPy import IP &gt;&gt;&gt; ip = IP(&#39;192.168.22.167&#39;) &gt;&gt;&gt; ip.reverseNames() #反向解析 [&#39;167.22.168.192.in-addr.arpa.&#39;] &gt;&gt;&gt; ip.iptype() &#39;PRIVATE&#39; &gt;&gt;&gt; IP(&#39;8.8.8.8&#39;).iptype() #8.8.8.8位公网 &#39;PUBLIC&#39; &gt;&gt;&gt; IP(&#39;8.8.8.8&#39;).int() #转为整型格式 134744072 &gt;&gt;&gt; IP(&#39;8.8.8.8&#39;).strHex() #转为十六进制 &#39;0x8080808&#39; &gt;&gt;&gt; IP(&#39;8.8.8.8&#39;).strBin() #转为二进制 &#39;00001000000010000000100000001000&#39; &gt;&gt;&gt; print(IP(0x8080808)) 8.8.8.8 IP 方法也支持网络地址的转换，如IP和掩码
&gt;&gt;&gt; from IPy import IP &gt;&gt;&gt; ip=IP(&#39;192.168.22.0/255.255.255.0&#39;,make_net=True) &gt;&gt;&gt; print(ip) 192.168.22.0/24 通过strNormal方法指定不同参数值以定制不同输出类型的网段，输出类型为字符串。
&gt;&gt;&gt; IP(&#39;192.168.22.0/24&#39;).strNormal(0) &#39;192.168.22.0&#39; &gt;&gt;&gt; IP(&#39;192.168.22.0/24&#39;).strNormal(1) &#39;192.168.22.0/24&#39; &gt;&gt;&gt; IP(&#39;192.168.22.0/24&#39;).strNormal(2) &#39;192.168.22.0/255.255.255.0&#39; &gt;&gt;&gt; IP(&#39;192.168.22.0/24&#39;).strNormal(3) &#39;192.168.22.0-192.168.22.255&#39; 3、多网络计算方法 判断IP地址和网段是否包含于同一网段中
&gt;&gt;&gt; &#39;192.168.22.100&#39; in IP(&#39;192.168.22.0/24&#39;) True &gt;&gt;&gt; IP(&#39;192.168.22.0/24&#39;) in IP(&#39;192.168.0.0/16&#39;) True 判断两个网段是否存在重叠，采用IPy 提供的 overlaps 方法
&gt;&gt;&gt; IP(&#39;192.168.0.0/23&#39;).overlaps(&#39;192.168.1.0/24&#39;) 1 #返回1代表存在重叠 &gt;&gt;&gt; IP(&#39;192.168.0.0/23&#39;).overlaps(&#39;192.168.22.0/24&#39;) 0 #返回0代表不存在重叠 4、综合应用 一个自动识别IP地址、子网、方向解析、IP类型的脚本
#!/usr/bin/env python3 # -*- coding: utf-8 -*- from IPy import IP ip_s = input(‘请输入IP地址或者网段地址: ‘) ips = IP(ip_s) #定义元素 if len(ips) &gt; 1: #如果len出来的数字大于1，那么就是一个网段 print(‘网络地址: %s’ % ips.net()) print(‘子网掩码: %s’ % ips.netmask()) print(‘网络广播地址: %s’ % ips.reverseNames() [0]) print(‘网络子网数: %s’ % len(ips)) else: ###否则就是一个地址 print(‘IP反向解析: %s’ % ips.reverseNames() [0]) print(‘十六进制地址: %s’ % ips.strHex()) print(‘二进制地址: %s’ % ips.strBin()) print(‘地址类型: %s’ % ips.iptype()) ]]></content></entry><entry><title>Python 发送电子邮件</title><url>/posts/python-send-mail/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html"><![CDATA[Email的历史比Web还要久远，直到现在，Email也是互联网上应用非常广泛的服务。本文介绍邮件的传递过程及使用Python实现邮件的发送。
一、基本概念 假设我们自己的电子邮件地址是me@163.com，对方的电子邮件地址是friend@sina.com，现在我们用Outlook或者Foxmail之类的软件写好邮件，填上对方的Email地址，点“发送”，电子邮件就发出去了。这些电子邮件软件被称为MUA：Mail User Agent——邮件用户代理。 Email从MUA发出去，不是直接到达对方电脑，而是发到MTA：Mail Transfer Agent——邮件传输代理，就是那些Email服务提供商，比如网易、新浪等等。由于我们自己的电子邮件是163.com，所以，Email首先被投递到网易提供的MTA，再由网易的MTA发到对方服务商，也就是新浪的MTA。 Email到达新浪的MTA后，由于对方使用的是@sina.com的邮箱，因此，新浪的MTA会把Email投递到邮件的最终目的地MDA：Mail Delivery Agent——邮件投递代理。Email到达MDA后，就静静地躺在新浪的某个服务器上，存放在某个文件或特殊的数据库里，我们将这个长期保存邮件的地方称之为电子邮箱。 Email不会直接到达对方的电脑，因为对方电脑不一定开机，开机也不一定联网。对方要取到邮件，必须通过MUA从MDA上把邮件取到自己的电脑上。 所以，一封电子邮件的旅程就是： 发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA &lt;- MUA &lt;- 收件人 发邮件时，MUA和MTA使用的协议就是SMTP：Simple Mail Transfer Protocol； 收邮件时，MUA和MDA使用的协议有两种：
POP：Post Office Protocol，目前版本是3，俗称POP3； IMAP：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱。 邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：smtp.163.com，为了证明你是163的用户，SMTP服务器还要求你填写邮箱地址和邮箱口令，这样，MUA才能正常地把Email通过SMTP协议发送到MTA。
二、SMTP发送邮件 SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。 Python 对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。 首先构造一个最简单的纯文本邮件：
#!/usr/bin/env python3 from email.mime.text import MIMEText import smtplib msg=MIMEText(&#39;Hello,Send by Python..&#39;,&#39;plain&#39;,&#39;utf-8&#39;) from_addr = input(&#39;From: &#39;) password = input(&#39;Password: &#39;) # 收件人地址 to_addr = input(&#39;To: &#39;) smtp_server = input(&#39;SMTP server: &#39;) server = smtplib.SMTP(smtp_server,25) server.set_debuglevel(1) server.login(from_addr,password) server.sendmail(from_addr, [to_addr], msg.as_string()) server.quit() 构造MIMEText对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入&rsquo;plain&rsquo;表示纯文本，最终的MIME就是&rsquo;text/plain&rsquo;，最后一定要用utf-8编码保证多语言兼容性。 用set_debuglevel(1)就可以打印出和SMTP服务器交互的所有信息。SMTP协议就是简单的文本命令和响应。login()方法用来登录SMTP服务器，sendmail()方法就是发邮件，由于可以一次发给多个人，所以传入一个list，邮件正文是一个str，as_string()把MIMEText对象变成str。
测试后发现用上面的方法发送会有问题： 1、邮件没有主题 2、收件人名字显示不友好 3、收到邮件却显示不在不在收件人中
这是因为邮件主题、如何显示发件人、收件人等信息并不是通过SMTP协议发给MTA，而是包含在发给MTA的文本中的，所以，我们必须把From、To和Subject添加到MIMEText中，才是一封完整的邮件：
#!/usr/bin/env python3 # Send email by Python3 from email import encoders from email.header import Header from email.mime.text import MIMEText from email.utils import parseaddr,formataddr import smtplib def _format_addr(s): name,addr = parseaddr(s) return formataddr((Header(name,&#39;utf-8&#39;).encode(),addr)) from_addr = input(&#39;From: &#39;) password = input(&#39;Password: &#39;) to_addr = input(&#39;To: &#39;) smtp_server = input(&#39;SMTP server: &#39;) msg=MIMEText(&#39;Hello,send by Python...&#39;,&#39;plain&#39;,&#39;utf-8&#39;) msg[&#39;From&#39;] = _format_addr(&#39;Python爱好 &lt;%s&gt;&#39; %from_addr) msg[&#39;To&#39;] = _format_addr(&#39;管理员 &lt;%s&gt;&#39; %to_addr) msg[&#39;Subject&#39;] = Header(&#39;来自SMTP&#39;,&#39;utf-8&#39;).encode() server=smtplib.SMTP(smtp_server,25) server.set_debuglevel(1) server.login(from_addr,password) server.sendmail(from_addr, [to_addr], msg.as_string()) server.quit() 这样便可以发送一个正常额邮件。注意发件人邮箱的密码为客户端授权密码，可网页登录邮箱进入管理后台查看。
zmail 收发邮件 zmail 是一个更好的用于发送邮件的库，使用简单
特征:
自动查找服务器地址及其端口。 自动使用合适的协议登录。 自动将python字典转换为MIME对象（带附件）。 自动添加邮件标题和本地名称，以避免服务器拒绝您的邮件。 轻松自定义邮件标题。 支持HTML作为邮件内容。 只需要python&gt; = 3.5 安装 pip3 install zmail 发送邮件 import zmail server = zmail.server(&#39;yourmail@example.com’, &#39;yourpassword&#39;) mail = { &#39;from&#39;: &#39;Zmail &lt;xxxx@163.com&gt;&#39;, &#39;subject&#39;: &#39;Success!&#39;, # Anything you want. &#39;content_text&#39;: &#39;This message from zmail!&#39;, # Anything you want. &#39;attachments&#39;: [&#39;/Users/zyh/Documents/example.zip&#39;,&#39;/root/1.jpg&#39;], # 附件 } if server.smtp_able(): # Send mail server.send_mail(&#39;yourfriend@example.com&#39;,mail) # Or to a list of friends. server.send_mail([&#39;friend1@example.com&#39;,&#39;friend2@example.com&#39;],	mail) 接收邮件 import zmail server = zmail.server(&#39;yourmail@example.com’, &#39;yourpassword&#39;) if server.pop_able(): # Retrieve mail latest_mail = server.get_latest() zmail.show(latest_mail) 自定义邮件服务器 server = zmail.server( &#39;username&#39;, &#39;password&#39;, smtp_host=&#39;smtp.163.com&#39;, smtp_port=994, smtp_ssl=True, pop_host=&#39;pop.163.com&#39;, pop_port=995, pop_tls=True ) 项目地址： https://github.com/ZYunH/zmail ]]></content></entry><entry><title>Mac OS下设置 Go 语言开发环境</title><url>/posts/mac-go-development/</url><categories><category>Golang</category></categories><tags><tag>Mac</tag></tags><content type="html"><![CDATA[Go 语言是由Google推出的一门编程语言，被认为是21世纪的 C语言，本文介绍如何在 Mac OS下设置Go语言开发环境，最快捷的方式使用brew安装 Go,再设置相应的环境变量。
安装 Go $ brew install go 设置环境变量 我使用的Shell是zsh,其它的依次类推，编辑家目录下的.zshenv，如果使用的bash,则相应的文件为~/.bash_profile
$ vim ~/.zshenv # Go development export GOPATH=$HOME/dev/go export GOROOT=&#34;$(brew --prefix golang)/libexec&#34; export PATH=&#34;$PATH:$GOPATH/bin:$GOROOT/bin&#34; 使环境变量生效 在命令行终端执行
$ sourse ~/.zshenv 查看环境变量是否生效 $ go env GOARCH=&#34;amd64&#34; GOBIN=&#34;/User/pengshp/dev/go/bin&#34; GOEXE=&#34;&#34; GOHOSTARCH=&#34;amd64&#34; GOHOSTOS=&#34;darwin&#34; GOOS=&#34;darwin&#34; GOPATH=&#34;/Users/pengshp/dev/go&#34; GORACE=&#34;&#34; GOROOT=&#34;/usr/local/opt/go/libexec&#34; GOTOOLDIR=&#34;/usr/local/opt/go/libexec/pkg/tool/darwin_amd64&#34; GCCGO=&#34;gccgo&#34; CC=&#34;clang&#34; CXX=&#34;clang++&#34; CGO_ENABLED=&#34;1&#34; CGO_CFLAGS=&#34;-g -O2&#34; CGO_CPPFLAGS=&#34;&#34; CGO_CXXFLAGS=&#34;-g -O2&#34; CGO_FFLAGS=&#34;-g -O2&#34; CGO_LDFLAGS=&#34;-g -O2&#34; PKG_CONFIG=&#34;pkg-config&#34; 开发工具 对于初期的学习老说，开发工具可以选用Sublime Text 3或者是VScode,Sublime安装一个GoSublime的插件，VScode也有相应的插件。
参考链接 1、Go官网： https://golang.google.cn/ 2、Go中文社区： https://studygolang.com/ 3、Go入门指南： http://wiki.jikexueyuan.com/project/the-way-to-go/ ]]></content></entry><entry><title>一些实用的工具</title><url>/posts/userful-tools/</url><categories><category>Tools</category></categories><tags><tag>Tools</tag></tags><content type="html">本文介绍一些实用的工具软件，长期更新。
1.hyper https://hyper.is hyper是一个纯JS/HTML/CSS打造的终端软件，具有漂亮的颜值和强大的功能，支持跨平台，MAC，Windows，Linux都支持。
2.chocolatey https://chocolatey.org chocolatey是Windows下的brew,可以很方便的在命令行中安装各种软件，从此告别繁琐的步骤，至于可以安装哪些软件可以到这个网站查询 传送门 3.OBS https://obsproject.com OBS Studio是一个开源免费的跨平台的录视频/直播软件，支持MAC，Windows，Linux平台。
4.Draw https://www.draw.io/ draw.io可以在线画各种图表，架构图等，用来理清思路在适合不过了。
5.Zhimap https://zhimap.com/home zhimap是一个免费在线思维导图工具，使用微信登录，使用方便，不用安装直接使用。
6.Excalidraw Excalidraw | Hand-drawn look &amp;amp; feel • Collaborative • Secure 简单的草图绘制</content></entry><entry><title>通信协议 SPI 总结</title><url>/posts/communication-protocal-spi/</url><categories><category>IoT</category></categories><tags><tag>IoT</tag></tags><content type="html"></content></entry><entry><title>通信协议 I2C 总结</title><url>/posts/communication-protocal-i2c/</url><categories><category>IoT</category></categories><tags><tag>IoT</tag></tags><content type="html">本文介绍同步串行总线I2C I2C简介 I2C是Philips公司开发的一种简单、双向二线制同步串行总线。只需要两根线即可在连接于总线上的器件之间传送信息。一根是串行数据线(SDA),一根是串行时钟线(SCL)。
传输过程 1.主机发送开始信号；
2.主机发出一字节的从机地址信息，其中最低位为读写控制位(1为读，0为写)，高七位为从机地址；
3.从机发出认可信号；
4.主机开始发送信号，每发送一字节后，从机发出认可信号给主机；
5.主机发出停止信号；
开始信号：SCL为高电平时，SDA由高电平变低电平 停止信号：SCL为高电平时，SDA由低电平变高电平 应答信号：主机写从机时，每写完一字节，如果正确从机将在下一个周期将数据线拉低，以告诉主机操作有效,该信号为ACK,无效时为NACK. 注意：任何在时钟线为高电平时数据线上的电平改变都被认为是开始信号/停止信号，所以数据改变必须在时钟线为低电平时改变。
总结 1.总线上的每一个从设备都有一个addr,共7bit,广播地址全为0，当有多个相同的从设备时，从设备的 addr 分为固定部分和可编程部分，细节视datasheet而定。
2.通信时一般都是一个主设备控制多个从设备进行通信，主设备根据从设备的器件地址决定要和哪一个从设备通信，这样便避免了信息正确的到达从设备。当有多个主设备尝试控制一个从设备时便要采取仲裁决定由主设备中的哪一个先与从设备通信。
I2C相关术语 术语 描述 发送器 发送数据到总线的器件 接收器 从总线接收数据的器件 主机 初始化发送、产生时钟信号和终止信号的器件 从机 被主机寻址的器件 多主机 同时又多余一个主机尝试控制总线，但不破坏报文 仲裁 多主机时只允许一个控制总线并使报文不破坏的过程 同步 两个或多个器件同步时钟信号的过程 参考 1.百度百科&amp;mdash;I2C总线
2. I2C协议解析</content></entry><entry><title>通信协议 UART 总结</title><url>/posts/communication-protocal-uart/</url><categories><category>IoT</category></categories><tags><tag>IoT</tag></tags><content type="html">UART是通用异步收发器（异步串行通信口）的英文缩写，主要包括RS232,RS485等接口标准和总线标准规范。还有一种是 USART(同步异步串行通信口)，但使用较少。
UART 简介 UART 协议主要包含三个引脚 串行发送引脚(TXD),串行接受引脚(RXD),电源参考地(GND)。当两个单片机进行通信时，电源地GND接在一起，然后单片机1的 TXD 引脚接单片机2的 RXD 引脚，即此路为单片机1发送二单片机2接收的通道；单片机1的 RXD 接到单片机2的 TXD 引脚，即此路为单片机2发送而单片机1接收的通道。如下所示： 当单片机1给单片机2发送数据时，比如发送一个 0xE4,二进制表示是11100100，是低位先发送，高位后发送。
波特率 在 UART 通信中有一个波特率的概念，即发送二进制数据位的速率，习惯用 baud 表示。当两个单片机进行通信是必须保证两个单片机的波特率一致。常用的波特率有9600，115200。在串口助手中设置波特率时一般设置为9600，校验位选N，数据位8，停止位1。 一个完整的 UART 数据帧由一个起始位(0)，8个数据位，一个停止位(1)构成. 串口调试工具 Minicom Minocom 是 Linux/OS X 下的一个串口调试命令行工具，在 Linux/OS X 下进行串口调试时一般都会使用此工具。
1、安装 # Ubuntu sudo apt install minicom # MAC brew install minicom 2、设置 安装完成后第一次使用需要设置，执行sudo minicom -s进行设置，设置为如下所示： 按对应项的字母进入相应的编辑选项，按照相应的说明编辑完成后回车，保存为默认配置，这样下次使用时直接使用minicom命令就可以使用。</content></entry><entry><title>推荐一些精选的网站</title><url>/posts/recommend-some-good-websites/</url><categories><category>Tools</category></categories><tags><tag>Tools</tag></tags><content type="html"><![CDATA[推荐一些有用的网站或工具。不定期更新&hellip;&hellip;
1、插件吧 http://chrome8.net 这网站是 Chrome 浏览器的插件下载网站，并且还推荐了很多好用的插件，Chrome 重度用户必备，并且不用**，你懂得！
2、免费高清图片 https://pixabay.com 这是我喜欢的网站，高质量的免费高清图片，并且不需要版权，随意使用！官方是这样介绍的可在任何地方使用的免费图片和视频。如果喜欢还有安卓APP 和iOS APP.
3、Smallpdf https://smallpdf.com 这个网站是对 PDF 进行处理的网站，各种文档格式的转换都能轻松解决，还可以分割，合并文档，对加密的文档去除密码[比较鸡肋，强密码就呵呵了&hellip;]。
4、中国谷歌开发者 https://developers.google.cn 没错，你没有看错！这是谷歌在中国重新开通的第一个服务，主要适用于 Android、Web 开发者使用。前不久传出谷歌将借助网易代理 Google Play 重返中国，希望 Google 中的可以回来，就不怕百毒毒害了。
5、Octave http://octave-online.net 这是 MATLAB 的替代品，再也不用安装臃肿的 MATLAB,在线编辑、执行 MATLAB 程序轻松搞定，对于轻度使用者足够了。
6、EasyEDA https://easyeda.com 高效的在线电子设计工具，可以画原理图，PCB，分享自己的作品，并且官方还配了一个使用教程。简直是电子工程师及爱好者的必备啊。
7、AUTODESK CIRUITS https://circuits.io 这也是一个电子设计爱好者的网站，可以在线画电路图，写代码，在线仿真。有意思的是可以在线仿真 Arduino ,实现你的各种创意想法。
8、DIY制作分享 http://www.instructables.com 国外的一个 DIY 制作分享网站，各种各样的 DIY 覆盖各个方面，每个都有详细的教程，是 DIY 爱好者的必备。
9、概念图设计 https://www.gliffy.com 概念图设计网站，做 PPT 时想做个概念图展示你的思路，那么这个网站可以帮助你。只需要简单退拽就可以轻松做一个漂亮的概念逻辑图。
10、幕布 http://mubu.io/ 便捷的在线思维导图工具,可以轻松制作漂亮的思维导图，当你烦躁的时候静下心来，制作一个思维导图，理清自己的思路，从此不必烦恼。
11、创客贴 https://www.chuangkit.com/ 极简的平面设计工具，具有丰富的场景、海量素材 精致的模板、操作便捷、有多种输出格式，平面设计师的必备佳品。
12、代码搜索神器 https://searchcode.com 程序眼必备佳品，可以搜索包括 GitHub、Bitbucket、Sourceforge、GitLab 等各大代码托管网站的代码，学习别人的优秀项目。官方的宣传语 Search over 20 billion lines of code from 7,000,000 projects
13、临时从命令行分享文件 https://transfer.sh/ 上传文件到网站，复制链接方便下载，在不同服务器之间分享文件时很方便。
暂时更新到这里，后续有好的网站会加上&hellip;..
版权声明：文章属作者原创，转载请联系博主，禁止用于商业用途！
]]></content></entry><entry><title>Python的包管理工具---pip</title><url>/posts/python-pip-packages/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html"><![CDATA[本文介绍Python的包管理工具Pip.
一.下载安装pip 到官网https://github.com/pypa/pip/releases下载最新的源码包，解压，进入包目录，执行下面的命令
sudo python3 setup.py install 二.更新pip版本 有时使用pip时会提示pip版本太旧，需要更新，可执行
python3 -m pip3 install -U pip3 三.常用命令 pip3 install [package name] # 安装软件包 pip3 uninstall [package name] # 卸载软件包 pip3 install --upgrade [package name] # 升级软件包 pip3 list --outdated # 列出可更新的软件包 pip3 download [package name] # 下载软件包 pip3 show [package name] # 显示已安装软件包的信息 pip3 search [package name] # 在pip源中搜寻相关的软件包 四.修改pip源 官方的pip源下载速度较慢，有时会出现超时不能下载的情况。这时就需要修改默认的pip源，建议使用阿里云的pip源。修改pip.conf文件
vim ~/.pip/pip.conf [global] trusted-host=mirrors.aliyun.com index-url=https://mirrors.aliyun.com/pypi/simple/ 保存退出，重启终端，文件不存在时需要新建。
五.一次性更新所有的软件包 新建一个upgrade_packages.py脚本，脚本内容如下所示：
import pip from subprocess import call def upgrade_all(): print(&#34;Upgrading all outdated packages......&#34;) for dist in pip.get_installed_distributions(): call(&#34;pip install --upgrade &#34; + dist.project_name, shell=True) if __name__ == &#39;__main__&#39;: upgrade_all() print(&#34;Upgrade finished!&#34;) 然后在终端中执行：
# Mac OS sudo -H python3 upgrade_packages.py 当长时间未更新时，Python的许多软件包就会有所更新，为了使用软件包最新的特性，便可以使用此方法一次性更新所有的软件包。 有些软件包的安装需要管理员权限，要使用sudo
六.参考链接 https://pip.pypa.io/en/latest/user_guide.html http://www.pip-installer.org/en/latest/configuration.html ]]></content></entry><entry><title>ESP8266控制DHT11的温湿度采集</title><url>/posts/iot-esp8266-oled-openhab-mqtt-micropython/</url><categories><category>IoT</category></categories><tags><tag>ESP8266</tag><tag>Micropython</tag></tags><content type="html"><![CDATA[项目描述：闲来无事，制作了一个用ESP8266控制DHT11采集温度，湿度并在OLED屏显示的系统，使用了MQTT协议上传网络在手机显示，编程语言使用MicroPython.巩固一下所学到的一些知识。
一、项目准备 1.所需材料 DHT11 温湿度传感器 NUDEMCU 开发板 IIC 接口 OLED 彩屏 小灯，电阻，面包板，导线若干 2.开发环境 MicroPython MQTT 二、项目制作 1.电路连接图 按照如上电路图连接，其中NUDEMCU的USB连接电脑USB.
2.编写main.py文件 from machine import Pin,I2C from time import sleep_ms from ubinascii import hexlify from umqtt.simple import MQTTClient from dht import DHT11 from ssd1306 import SSD1306_I2C import machine,json #---MQTT Sending--- SERVER=&#34;iot.eclipse.org&#34; CLIENT_TD=hexlify(machine.unique_id()) led = Pin(2, Pin.OUT, value=1) TOPIC1=b&#34;/dht11/tem&#34; TOPIC2=b&#34;/dht11/hum&#34; TOPIC3=b&#34;/dht11/led&#34; def envioMQTT(server=SERVER,topic=&#34;/foo&#34;,data=None): try: c=MQTTClient(CLIENT_TD,server) c.connect() c.publish(topic,data) sleep_ms(200) c.disconnect() except Exception as e: pass state=0 def sub_cb(topic,msg): global state print((topic,msg)) if msg == b&#34;on&#34;: led.value(1) state=1 elif msg == b&#34;off&#34;: led.value(0) state=0 def recepcionMQTT(server=SERVER,topic=TOPIC3): c = MQTTClient(CLIENT_TD,server) # Subscribed messages will be delivered to this callback c.set_callback(sub_cb) c.connect() c.subscribe(topic) try: c.wait_msg() finally: c.disconnect() #---End MQTT Sending--- #---DHT11--- ds=DHT11(Pin(16)) def read_dht(): try: ds.measure() tem=ds.temperature() hum=ds.humidity() return (tem,hum) except Exception as e: return (-1,-1) #---End DHT11--- #---OLED IIC 128x64--- i2c = I2C(sda = Pin(4), scl = Pin(5)) display = SSD1306_I2C(128, 64, i2c) def displaytem(tem,hum): display.fill(0) temperatura = &#39;Tempera: &#39; + str(tem)[:5] + &#39;C&#39; humedad = &#39;Humidty: &#39; + str(hum)[:5] + &#39;%&#39; display.text(&#39;DHT11,ESP8266&#39;,0,0,1) display.text(temperatura,2,24,1) display.text(humedad,2,34,1) display.show() #---End OLED--- #---Main Program--- sleep_ms(10000) def main(): while True: (tem,hum) = read_dht() displaytem(tem,hum) envioMQTT(SERVER,TOPIC1,json.dumps(tem)) envioMQTT(SERVER,TOPIC2,json.dumps(hum)) recepcionMQTT() sleep_ms(10000) #---END Main Program--- if __name__ == &#39;__main__&#39;: main() 3.项目描述 使用了iot.eclipse.org的MQTT服务; ESP8266运行的是Micropython的固件，需自行烧写； main.py文件使用 Micropython的webrepl服务上传，复位后自动运行； 手机端下载一个MQTT Client ,连上iot.eclipse.org，并且订阅这些消息便可以看到收到的信息。 效果如下所示： 三、参考连接 1.webrepl: http://micropython.org/webrepl/ 2.MQTT Server: http://mqtt.org/documentation 3.iot.eclipse: http://iot.eclipse.org 4.MicroPython: http://micropython.org ]]></content></entry><entry><title>使用 Checkinstall 编译打包Debian包</title><url>/posts/checkinstall-build-debian-packge/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html">有时我们需要把一个安装包编译成xx.deb格式的安装包，以实现编译一次就可以在其他系统上运行的目的。这时就可以使用Checkinstall,它是一个很好用的linux源码安装工具，是本文介绍使用Checkinstall 编译Debian包，以编译mosquitto为例.
1.下载mosquitto源码包 wget http://mosquitto.org/files/source/mosquitto-1.4.10.tar.gz 2.解压源码包 tar -zxvf mosquitto-1.4.10.tar.gz 3.编译源码包 cd mosquitto-1.4.10 make 4.使用checkinstall编译打包 sudo apt-get install checkinstall sudo checkinstall --install=no --pkgversion 1.4.10 # 后面两个参数表示打包后不安装，设置软件包版本。 5.设置软件包参数 回车后会让你为这个软件包写一段描述，以空行或者EOF结束，接着会设置具体参数，比如下面的所示：
***************************************** **** Debian package creation selected *** ***************************************** 软件包将用下面的值来创建： 0 - Maintainer: [ root@raspberrypi ] 1 - Summary: [ An Mosquitto Server(MQTT) by pengshp(mail:pengshp3@outlook.com) ] 2 - Name: [ mosquitto ] 3 - Version: [ 1.4.10 ] 4 - Release: [ 1 ] 5 - License: [ GPL ] 6 - Group: [ checkinstall ] 7 - Architecture: [ armhf ] 8 - Source location: [ mosquitto-1.4.10 ] 9 - Alternate source location: [ ] 10 - Requires: [ ] 11 - Provides: [ mosquitto ] 12 - Conflicts: [ ] 13 - Replaces: [ ] 输入一个数字来改变它们，或按回车键继续： 一般默认即可，这样便可以在当前目录下生成mosquitto_1.4.10-1_armhf.deb。便可以保存下来再其他系统上也可安装。
6.安装软件包 sudo dpkg -i mosquitto_1.4.10-1_armhf.deb</content></entry><entry><title>命令行终端中使用代理下载</title><url>/posts/terminal-use-proxy/</url><categories><category>MacOS</category></categories><tags><tag>Linux</tag></tags><content type="html">摘要：你是否还在烦恼有时下载一个软件半天下载不了？要么超时要么连接不上，因为被墻，别头疼了，ProxyChains-NG能帮你解决烦恼，需要在命令行中下载一些需要fq才能下载的软件，这时就可以安装及配置 ProxyChains-NG 实现终端下代理，下载介绍如何安装及配置。
项目主页： https://github.com/rofl0r/proxychains-ng 一.下载安装ProxyChains-NG # Mac OS brew install proxychains-ng # Ubuntu sudo apt install proxychains-ng 二.配置 编辑配置文件/usr/local/etc/proxychains.conf[Mac OS] /etc/proxychains.conf[Ubuntu] 在 [ProxyList] 下面（也就是末尾）加入代理类型，代理地址和端口，可以选择本地127.0.0.1,也可以选择局域网内的其他代理服务器，并根据自己的代理类型进行配置。 例如使用 TOR 代理，注释掉原来的代理并添加
socks5 127.0.0.1 1080 #socks5代理 http 192.168.100.88 8123 #http代理 三.使用 proxychains4 wget youtube.com 如果返回一堆html代码说明配置成功了。
如果使用有问题请参考： 1、 https://eliyar.biz/proxy-for-mac-terminal/</content></entry><entry><title>Linux下搭建STM32开发环境</title><url>/posts/system-workbench-for-stm32-on-linux/</url><categories><category>STM32</category></categories><tags><tag>STM32</tag><tag>Linux</tag></tags><content type="html"><![CDATA[摘要：这个系统工具链叫做SW4STM32,是一个免费的基于Eclipse的multi-OS软件开发环境，它支持所有的STM32开发板及有关的开发板。这个产品是第三方提供而不是ST官方，最新的消息可以访问第三方的网站： http://www.ac6.fr 主要特点： 支持全系列的STM32开发板，包括STM32 Nucleo,Discovery套件和Evaluation.以及STM32固件（标准库或者STM32Cube HAL） GCC C/C++编译器 GDB-based 调试器 带团队管理工具的Eclipse IDE 兼容Eclipse插件 ST-LINK 支持 没有代码量的限制 Multiple OS支持：Windows, Linux, OS X 一.在Ubuntu GNOME 16.04上安装开发环境 1.安装之前需要安装java运行环境，进入命令行 $ sudo add-apt-repository ppa:webupd8team/java $ sudo apt-get update $ sudo apt-get install oracle-java8-installer 2.下载安装脚本 # 32bit $ wget http://www.ac6-tools.com/downloads/SW4STM32/install_sw4stm32_linux_32bits-latest.run # 64bit $ wget http://www.ac6-tools.com/downloads/SW4STM32/install_sw4stm32_linux_64bits-latest.run 3.对于Ubuntu 64-bit,需下载而外的工具 $ sudo apt-get install libc6:i386 lib32ncurses5 4.为了启动GUI模式，需要安装gksu $ sudo apt-get install gksu 5.进入下载目录执行 $ chmod +x install_sw4stm32_linux_64bits-v1.8.run $ ./install_sw4stm32_linux_64bits-v1.8.run 6.安装完成后点击Help&ndash;&gt;Update更新最新的固件库。 二.建立工程项目 依次点击File&ndash;&gt;Project&ndash;&gt;C Project&ndash;&gt;C Project&ndash;&gt;Next,j加上工程的名字，Project type选择Ac6 STM32 MCU Project,Toolchains默认，再Next--&gt;Next,Series里选择STM32的主型号，Board里选择具体的型号。再``Next--&gt;Finish`.
到此整个搭建过程就完成了，接下来就是使用它来实现你的想法，Enjoy it!!
参考： 1. http://www.st.com 2. http://www.openstm32.org ]]></content></entry><entry><title>Raspbian 安装最新版 docker</title><url>/posts/raspbian-install-docker/</url><categories><category>Docker</category></categories><tags><tag>Docker</tag><tag>RaspberryPi</tag></tags><content type="html"><![CDATA[
一.问题描述 执行docker pull命令时经常不能pull images,显示如下错误
Could not reach any registry endpoint. Google后才知道Raspbian中默认安装的docker版本是1.3.3，而docker更新后一些性能不在支持1.5及以下的版本，所以才会出现这样的问题。为了能够正常使用，要更新到较新的版本。
二.安装配置 1.先卸载旧版本的docker $ sudo apt-get remove --purge docker docker-io 2.使用官方脚本安装docker $ curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 3.为了使用户能够使用docker,把它加入用户组 $ sudo usermod -aG docker pi 这样在执行docker命令的时候就不需要加上sudo. 根据系统提示，重新启动系统或者重新登录，便可以正常的使用docker.
4.配置镜像加速器 $ vim /etc/docker/daemon.json { &#34;registry-mirrors&#34;: [ &#34;https://docker.mirrors.ustc.edu.cn/&#34;, &#34;https://dockerhub.azk8s.cn&#34; ], &#34;insecure-registries&#34;: [] } 5.限制容器日志的大小 ~$ vim /etc/docker/daemon.json { &#34;log-driver&#34;: &#34;json-file&#34;, &#34;log-opts&#34;: { &#34;max-size&#34;:&#34;1m&#34;, &#34;max-file&#34;:&#34;2&#34; } } # 重启Docker ~$ sudo systemctl restart docker 若不做配置，容器产生的日志会不断增大，可能到几GB，上面配置每个容器最多产生5MB的日志，最多保留2个日志文件。
容器日志清理脚本 #!/bin/sh # Clean Docker log. echo &#34;======== start clean docker containers logs ========&#34; logs=$(find /var/lib/docker/containers/ -name *-json.log) for log in $logs do echo &#34;clean logs : $log&#34; cat /dev/null &gt; $log done echo &#34;======== end clean docker containers logs ========&#34; 执行此脚本，可清理容器产生的日志。
6.有时出了问题，可以卸载重新安装 $ sudo apt-get remove --auto-remove docker-engine 三.docker教程参考 Docker —— 从入门到实践 参考： 1. https://www.raspberrypi.org/blog/docker-comes-to-raspberry-pi/ 2. Could not reach any registry endpoint ]]></content></entry><entry><title>Shell+Curl实现网页爬虫</title><url>/posts/shell-curl-web-spide/</url><categories><category>Shell</category></categories><tags><tag>Shell</tag><tag>Curl</tag></tags><content type="html"><![CDATA[使用shell和curl监测海贼王的更新并发邮件到邮箱！
一.项目描述 为了能进入导师实验室，师兄分给我一个项目，用shell脚本和curl实现一个网络爬虫，主要功能是检测某个网站海贼王的更新信息，当有最新剧集更新时发送邮件提醒。作为对我的考验，刚开始我没有思路，学了一段时间的shell脚本，又从网上查了一些资料，但感觉没思路；后来问了一个软件学院的师兄，可以用正则表达式匹配出最大值，与上一次的值比较，大于则发送邮件。
二.源码实现 #Function: 监测海贼王更新并提醒 #Author: pengshp #Time: 2015-9 #! /bin/bash URL=&#34;http://www.fzdm.com/manhua/002/&#34; LOG_DIR=${HOME}/logs #发送邮件函数 smail(){ mail -s &#34;更新提醒&#34; $MAIL &lt;&lt; EOF ================================== Report Time: `date +&#34;%F %T&#34;` Current User: `whoami` 海贼王已经有更新，请打开下列链接前往观看! 风之动漫： http://www.fzdm.com/manhua/002/ =================================== EOF } read -p &#34;Please input your 163 mail: &#34; MAIL Result=`curl -o /dev/null -s -m 10 --connect-timeout 10 -w %{http_code} $URL` Test=`echo $Result` #监测网站是否可以正常访问 if [ &#34;$Test&#34; == &#34;200&#34; ] then if [ ! -f $LOG_DIR ] then mkdir -p $LOG_DIR fi cd $LOG_DIR touch log.txt let Value1=800 #现在最新是800话 while true do curl -s -o page.html http://www.fzdm.com/manhua/002/ #利用正则表达式获取HTML文件中最新的剧集的值 let Value=$(cat page.html |grep &#39;title=&#34;海贼王[0-9].*&#34;&#39; |sed -n &#39;1p&#39; |awk -F &#39;&#34;&#39; &#39;{print $4}&#39; |cut -d &#39;/&#39; -f1) if [ $Value -gt $Value1 ] then smail echo &#34;successfully! `date` &#34; &gt;&gt; log.txt let Value1=Value #更新最新的剧集 fi rm page.html sleep 300 done fi 程序中用到mail命令，需要自己配置相应的环境，把要发送的内容封装起来，以EOF结尾。接受的邮箱可以自己定义。
]]></content></entry><entry><title>树莓派 Archlinux ARM 安装yaourt</title><url>/posts/raspi-archlinuxarm-install-yaourt/</url><categories><category>RaspberryPi</category></categories><tags><tag>RaspberryPi</tag><tag>Linux</tag></tags><content type="html">摘要：yaourt是一个比pacman更好用的包管理工具，集成了很多额外的软件包。正常情况下树莓派Archlinux ARM不能使用sudo pacman -S yaourt安装yaourt,下面介绍一种方法安装yaourt.
一.配置环境 1.添加源 修改/etc/pacman.conf,添加如下内容
[archlinuxfr] Server = http://repo.archlinux.fr/arm SigLevel = Never 2.手动安装package-query sudo pacman -S yajl #安装依赖 curl -O https://aur.archlinux.org/cgit/aur.git/snapshot/package-query.tar.gz tar -xzvf package-query.tar.gz cd package-query makepkg -si 如果一切正常，便可以编译生成package-query-1.8-2-armv7h.pkg.tar.xz,期间会下载package-query-1.8.tar.gz,但是我的一直不能下载下来，显示超时，可以到 这里 下载,scp放到package-query目录下。
二.安装使用 1.执行下面的命令便可以安装yaourt cd .. sudo pacman -S yaourt 2.基本使用 yaourt -S package_name – 从AUR安装软件包 yaourt -Ss password – 使用关键字搜索软件包 yaourt -Syu –aur – 从AUR升级本地软件数据库并安装更新 yaourt -Si package_name – 列出软件包信息 yaourt -Sc – 从缓存中清楚旧的软件包 yaourt -Su – 安装AUR中的更新软件包 yaourt -Sy – 获取最新的AUR软件包数据库 yaourt -Cd – 清楚AUR软件包数据库 yaourt -R package_name – 删除软件包 到此yaourt的安装介绍就完了，体验一下yaourt的强大吧！enjoy it!
更新：yaourt已被弃用，推荐使用Go语言编写的yay,功能更加强大！
Jguer/yay: Yet another Yogurt - An AUR Helper written in Go (github.com)</content></entry><entry><title>免密码登录树莓派</title><url>/posts/password-less-logins-pi/</url><categories><category>Linux</category></categories><tags><tag>RaspberryPi</tag></tags><content type="html">摘要：平时在终端中登录树莓派每次都要输密码等，比较麻烦，因此找到一个比较简单的登录方法，只需要在终端输入ssh pi便可以登录，下面介绍配置方法.
一.测试环境： 系统：MacOS X shell: zsh 登录：RaspberryPi3B 二.设置方法 1.用ssh-keygen生成ssh密钥
$ ssh-keygen -t rsa -b 1024 $ cat ~/.ssh/id_rsa.pub 2.安装ssh-copy-id
$ brew install ssh-copy-id # MacOS X $ sudo apt install ssh-copy-id # Ubuntu/Debian $ yum install -y ssh-copy-id # CentOS 3.把公钥上传到树莓派
$ ssh-copy-id pi@192.168.10.195 #改为树莓派的IP地址 再输入登录密码，回车便可以了。
4.在家目录下新建.ssh/config
$ vim ~/.ssh/config Host pi Hostname 192.168.10.195 user pi port 22 IdentityFile ~/.ssh/id_rsa 加入以下所示的内容即可，pi的名字可自己随便起，保存退出。 5.登录树莓派 现在在终端中执行ssh pi便可以登录。
附：解决xshell密钥验证登录需要输入密码的问题 $ chmod 700 ~/.ssh $ chmod 600 ~/.ssh/authorized_keys</content></entry><entry><title>OpenWrt-SDK编译自己的ipk包</title><url>/posts/openwrt-sdk-build-packages/</url><categories><category>OpenWrt</category></categories><tags><tag>OpenWrt</tag><tag>SDK</tag></tags><content type="html">本问介绍如何使用OpenWrt编译自定义的ipk包。
上一篇文章介绍了编译openwrt固件和SDK，现在介绍一下使用OpenWrt-SDK编译自己的安装包，此次以OpenWrt-SDK-brcm2708-bcm2709_gcc-4.8-linaro_uClibc-0.9.33.2_eabi.Linux-i686为工具链编译sysuh3c[中山大学东校区校园网认证]
一.开发环境 1.Ubuntu14.10 32bit 2.OpenWrt-SDK 二.编译设置 1.新建一个目录下载软件包
$ mkdir sysuh3c $ git clone 2.把下载的软件包复制到OpenWrt-SDK的package目录下
$ cp sysuh3c OpenWrt-SDK-brcm2708-bcm2709_gcc-4.8-linaro_uClibc-0.9.33.2_eabi.Linux-i686/package 3.修改sysuh3c的Makefile配置文件
$ cd sysuh3c $ vim Makefile 主要修改系统架构和版本等信息，如下图所示，这里改为树莓派2B的架构bcm2709,这个工具链也可以用来编译树莓派1代【brcm2708】的ipk包
在package目录下执行tree查看目录树应该是这样
. ├── Makefile └── sysuh3c ├── Makefile ├── README.md └── src ├── eapauth.c ├── eapauth.h ├── eapdef.h ├── eaputils.c ├── eaputils.h ├── main.c ├── Makefile └── sysuh3c.conf 2 directories, 11 files 注意修改的是sysuh3c目录下的Makefile，其他文件不要作任何修改
三.编译 1.回到OpenWrt-SDK-brcm2708-bcm2709_gcc-4.8-linaro_uClibc-0.9.33.2_eabi.Linux-i686目录下，执行下面的命令
$ make 2.编译好的ipk安装包在bin/brcm2708/packages/base
$ cd bin/brcm2708/packages/base $ ls sysuh3c_2.0-0_bcm2709.ipk 三.安装ipk包 使用winscp将sysuh3c_2.0-0_bcm2709.ipk上传到路由器的/tmp目录下，使用 Putty ssh登陆到路由器执行下面的命令
$ cd /tmp $ opkg install sysuh3c_2.0-0_bcm2709.ipk OpenWrt-SDK一般自己编译一个，官网下载的编译时有问题，编译的环境最好选择32bit的Ubuntu系统。不然很容易出问题，编译OpenWrt-SDK和固件时最好别选过多的其他功能或者包，不然很容易出问题导致编译失败，需要的安装包可以编译好后下载安装或者自己编译。</content></entry><entry><title>令人震惊的单行Python代码</title><url>/posts/surprised-python-code/</url><categories><category>Python</category></categories><tags><tag>Python</tag></tags><content type="html"><![CDATA[本文主要介绍几条简短的但功能强大的Python代码，主要是Python3环境，建议在IPython3环境中运行。
1.让列表中的每个元素都乘以２ print (map(lambda x: x*2,range(1,11))) 2.求列表中的所有元素的和 print　(sum(range(1,1001))) 3.判断一个字符串中是否存在某些词 wordlist = [&quot;scala&quot;,&quot;akka&quot;,&quot;play frame work&quot;,&quot;sbt&quot;,&quot;typesafe&quot;] tweet = &quot;This is an example tweet talking about scala and sbt.&quot; print (map(lambda x: x in tweet.split(),wordlist)) 4.读取文件 print (open(&quot;ten_one_liners.py&quot;).readlines()) 5.祝你生日快乐 print (map(lambda x: &quot;Happy Birthday to &quot;+ (&quot;you&quot; if x != 2 else &quot;dear Name&quot;),range(4))) 6.过滤列表中的数值 print (reduce(lambda(a,b),c): (a+[c],b) if c&gt;60 else (a,b + [c]),[49,58,76,82,88,90],([],[])) 7.找出列表中最大或者最小的一个数字 print (min([14,35,-7,46,98])) print (max([14,35,-7,46,98])) 8.并行处理 import multiprocessing import math print(list(multiprocessing.Pool(processes=4).map(math.exp,range(1,11)))) ]]></content></entry><entry><title>Raspberrypi3的UbuntuMate16.04上安装最新qt5</title><url>/posts/raspberrypi3-ubuntumate-qt5/</url><categories><category>RaspberryPi</category></categories><tags><tag>RaspberryPi</tag></tags><content type="html"><![CDATA[本文主要介绍在树莓派３上的UbuntuMate16.04上安装最新的ＱＴ５开发环境！加上简单的配置和运行一个hello word程序!本教程也适用于Raspbian系统。
一.安装qt5 运行下面几条命令下载安装最新的qt5
sudo apt-get update sudo apt-get install qt5-defalut sudo apt-get install qtcreator 二.配置qt5 从菜单栏中打开qtcreator，依此选择工具&ndash;&gt;选项&ndash;&gt;构建和运行&ndash;&gt;编辑器&ndash;&gt;添加&ndash;&gt;GCC,浏览里选择/usr/bin/gcc或者交叉编译/usr/bin/arm-linux-guneabihf-gcc,点击Apply&ndash;&gt;OK.
三.简单测试 回到欢迎菜单，选择New Project&ndash;&gt;Nor-QT Project&ndash;&gt;Plain C++ Application,选择choose,填写项目名和路径，下一步，Build system选择默认的qmake,再一直下一步，完成。写个简单的hello word程序测试： 点击左下角小锤子的图标构建（快捷键Ctrl+B）编译，点击绿色的三角形图标运行（快捷键Ctrl+R）运行程序。如果没有错误就会打开终端显示运行结果。 到此配置结束，enjoy it!开启你的ＱＴ之旅吧！
]]></content></entry><entry><title>Ｘshell自定义配色方案</title><url>/posts/xshell-colour/</url><categories><category>Linux</category></categories><tags><tag>Linux</tag></tags><content type="html">经常使用xshell来操作Linux的朋友都知道，xshell默认的配色方案很不好看，看着都不舒服，所以从网上找了几个比较好看的配色方案，与各位分享！
一.方案一:Solarized Dark [Names] count=1 name0=Solarized Dark [Solarized Dark] text(bold)=839496 magenta(bold)=6c71c4 text=00ff40 white(bold)=fdf6e3 green=859900 red(bold)=cb4b16 green(bold)=586e75 black(bold)=073642 red=dc322f blue=268bd2 black=002b36 blue(bold)=839496 yellow(bold)=657b83 cyan(bold)=93a1a1 yellow=b58900 magenta=dd3682 background=042028 white=eee8d5 cyan=2aa198 二.方案二:自定义方案 [myxshell] text(bold)=e9e9e9 magenta(bold)=ff00ff text=00ff80 white(bold)=fdf6e3 green=80ff00 red(bold)=ff0000 green(bold)=3c5a38 black(bold)=808080 red=ff4500 blue=00bfff black=000000 blue(bold)=1e90ff yellow(bold)=ffff00 cyan(bold)=00ffff yellow=c0c000 magenta=c000c0 background=042028 white=c0c0c0 cyan=00c0c0 [Names] count=1 name0=myxshell 三.使用方法 1.以上方案可以存入txt文本中，然后修改后缀名为xcs再导入就可以了。
2.具体颜色就不上图了，各位自己导入看吧，在xshell界面右键选择配色方案&amp;ndash;&amp;gt;导入，就可以看到了。</content></entry><entry><title>树莓派2/３安装Archlinux教程</title><url>/posts/raspberrypi3-install-archlinux/</url><categories><category>RaspberryPi</category></categories><tags><tag>RaspberryPi</tag><tag>Linux</tag></tags><content type="html">本文主要介绍最新的树莓派2/３安装Ａrchlinux系统的主要步骤。树莓派官方最近发布了最新的树莓派３，与上一代树莓派２B+相比，标配了蓝牙和wifi，主频达到1.2GHz,速度更快也更加流畅了。拿到手后赶快体验了一把。
一.准备工作 一台Linux操作系统的电脑 一张８Ｇ的ＳＤ卡 树莓派３主板 二.下载安装 1.插入SD卡，首先卸载卡，执行下面的命令 $ sudo umount /media/EAN-7EDS 后面的EAN-7EDS根据自己的情况，插入一张卡的话，一般按Tab键补齐
2.在Ubuntu中执行下面命令查看挂载的位置我的是/dev/sdb $ sudo fdisk -l 3.终端执行下面命令下载系统文件 $ sudo mkdir archlinux $ cd archlinux $ wget http://mirrors.ustc.edu.cn/archlinuxarm/os/ArchLinuxARM-rpi-2-latest.tar.gz 4.为SD卡分区 $ sudo fdisk /dev/sdb 输入 o 并回车，这将会删除所有分区 输入 p 并回车，这将会列出所有分区，此时应该没有任何分区 输入 n 并回车，创建新分区，引导分区 输入 p 并回车，新分区为主分区 输入 1 并回车，分区序号是1 按键盘回车，默认初始扇区 输入 +100M 并回车，设置终止扇区 输入 t 并回车，再输入 c 并回车，设置该分区文件系统格式为Fat32 输入 n 并回车，创建新分区，根分区 输入 p 并回车，新分区为主分区 输入 2 并回车，分区序号是2 按键盘回车，默认初始扇区 按键盘回车，默认终止扇区 输入 w 并回车，写入设置
4.格式化分区 $ sudo mkfs.vfat /dev/sdb1 $ sudo mkfs.ext4 /dev/sdb2 5.创建挂载位置并挂载分区 $ sudo mkdir boot root $ sudo mount /dev/sdb1 boot $ sudo mount /devsdb2 root 6.解压文件到root目录 $ sudo apt-get install bsdtar $ sudo badtar -xpf ArchLinuxARM-rpi-2-latest.tar.gz -C root 7.清空缓存 $ sudo sync 8.把boot中的文件移动到第一个分区 $ mv root/boot/* boot 9.卸载两个分区 $ sudo umount boot/ root/ 10.取下卡，插入树梅派上电即可启动 ssh登录用户名：alarm 密码：alarm
备注：到目前位置，针对树莓派3B　Cotex-A53 64位架构的镜像包还没有发布，暂时使用的使树莓派２B的ArmV7架构,不够根据官网的描述，未来将会通过更改64bit的软件源实现更新！ 到此就装完了，一些基本配置参考： Raspberry Pi 简体中文</content></entry></search>